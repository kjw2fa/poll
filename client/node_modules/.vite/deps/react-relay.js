import {
  require_EntryPointContainer_react,
  require_ProfilerContext,
  require_ReactRelayContext,
  require_RelayEnvironmentProvider,
  require_loadEntryPoint,
  require_loadQuery,
  require_objectWithoutPropertiesLoose,
  require_relay_runtime,
  require_useEntryPointLoader,
  require_useFragment,
  require_useLazyLoadQuery,
  require_useLoadMoreFunction,
  require_useMutation,
  require_usePaginationFragment,
  require_usePreloadedQuery,
  require_useQueryLoader,
  require_useRefetchableFragment,
  require_useRefetchableFragmentInternal,
  require_useRelayEnvironment,
  require_useStaticFragmentNodeWarning,
  require_useSubscribeToInvalidationState,
  require_useSubscription
} from "./chunk-6SGSPMAF.js";
import {
  require_areEqual,
  require_browser,
  require_defineProperty,
  require_interopRequireDefault,
  require_objectSpread2,
  require_warning
} from "./chunk-KXN4HSQF.js";
import {
  require_react
} from "./chunk-7HQUOLNA.js";
import {
  __commonJS
} from "./chunk-G3PMV62Z.js";

// ../node_modules/@babel/runtime/helpers/extends.js
var require_extends = __commonJS({
  "../node_modules/@babel/runtime/helpers/extends.js"(exports, module) {
    function _extends() {
      return module.exports = _extends = Object.assign ? Object.assign.bind() : function(n) {
        for (var e = 1; e < arguments.length; e++) {
          var t = arguments[e];
          for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
        }
        return n;
      }, module.exports.__esModule = true, module.exports["default"] = module.exports, _extends.apply(null, arguments);
    }
    module.exports = _extends, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// ../node_modules/@babel/runtime/helpers/assertThisInitialized.js
var require_assertThisInitialized = __commonJS({
  "../node_modules/@babel/runtime/helpers/assertThisInitialized.js"(exports, module) {
    function _assertThisInitialized(e) {
      if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return e;
    }
    module.exports = _assertThisInitialized, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// ../node_modules/@babel/runtime/helpers/setPrototypeOf.js
var require_setPrototypeOf = __commonJS({
  "../node_modules/@babel/runtime/helpers/setPrototypeOf.js"(exports, module) {
    function _setPrototypeOf(t, e) {
      return module.exports = _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t2, e2) {
        return t2.__proto__ = e2, t2;
      }, module.exports.__esModule = true, module.exports["default"] = module.exports, _setPrototypeOf(t, e);
    }
    module.exports = _setPrototypeOf, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// ../node_modules/@babel/runtime/helpers/inheritsLoose.js
var require_inheritsLoose = __commonJS({
  "../node_modules/@babel/runtime/helpers/inheritsLoose.js"(exports, module) {
    var setPrototypeOf = require_setPrototypeOf();
    function _inheritsLoose(t, o) {
      t.prototype = Object.create(o.prototype), t.prototype.constructor = t, setPrototypeOf(t, o);
    }
    module.exports = _inheritsLoose, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// ../node_modules/react-relay/lib/assertFragmentMap.js
var require_assertFragmentMap = __commonJS({
  "../node_modules/react-relay/lib/assertFragmentMap.js"(exports, module) {
    "use strict";
    var invariant = require_browser();
    function assertFragmentMap(componentName, fragmentSpec) {
      !(fragmentSpec && typeof fragmentSpec === "object") ? true ? invariant(false, "Could not create Relay Container for `%s`. Expected a set of GraphQL fragments, got `%s` instead.", componentName, fragmentSpec) : invariant(false) : void 0;
      for (var key in fragmentSpec) {
        if (fragmentSpec.hasOwnProperty(key)) {
          var fragment = fragmentSpec[key];
          !(fragment && (typeof fragment === "object" || typeof fragment === "function")) ? true ? invariant(false, "Could not create Relay Container for `%s`. The value of fragment `%s` was expected to be a fragment, got `%s` instead.", componentName, key, fragment) : invariant(false) : void 0;
        }
      }
    }
    module.exports = assertFragmentMap;
  }
});

// ../node_modules/react-relay/lib/ReactRelayContainerUtils.js
var require_ReactRelayContainerUtils = __commonJS({
  "../node_modules/react-relay/lib/ReactRelayContainerUtils.js"(exports, module) {
    "use strict";
    function getComponentName(component) {
      return component.displayName || component.name || "Component";
    }
    function getContainerName(Component) {
      return "Relay(" + getComponentName(Component) + ")";
    }
    module.exports = {
      getComponentName,
      getContainerName
    };
  }
});

// ../node_modules/react-relay/lib/ReactRelayQueryRendererContext.js
var require_ReactRelayQueryRendererContext = __commonJS({
  "../node_modules/react-relay/lib/ReactRelayQueryRendererContext.js"(exports, module) {
    "use strict";
    var React = require_react();
    module.exports = React.createContext({
      rootIsQueryRenderer: false
    });
  }
});

// ../node_modules/react-relay/lib/buildReactRelayContainer.js
var require_buildReactRelayContainer = __commonJS({
  "../node_modules/react-relay/lib/buildReactRelayContainer.js"(exports, module) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault()["default"];
    var _extends2 = _interopRequireDefault(require_extends());
    var assertFragmentMap = require_assertFragmentMap();
    var _require = require_ReactRelayContainerUtils();
    var getComponentName = _require.getComponentName;
    var getContainerName = _require.getContainerName;
    var ReactRelayContext = require_ReactRelayContext();
    var ReactRelayQueryRendererContext = require_ReactRelayQueryRendererContext();
    var invariant = require_browser();
    var React = require_react();
    var _require2 = require_relay_runtime();
    var getFragment = _require2.getFragment;
    var useContext = React.useContext;
    function buildReactRelayContainer(ComponentClass, fragmentSpec, createContainerWithFragments) {
      var containerName = getContainerName(ComponentClass);
      assertFragmentMap(getComponentName(ComponentClass), fragmentSpec);
      var fragments = {};
      for (var key in fragmentSpec) {
        fragments[key] = getFragment(fragmentSpec[key]);
      }
      var Container = createContainerWithFragments(ComponentClass, fragments);
      Container.displayName = containerName;
      function ForwardRef(props, ref) {
        var _queryRendererContext;
        var context = useContext(ReactRelayContext);
        !(context != null) ? true ? invariant(false, "`%s` tried to render a context that was not valid this means that `%s` was rendered outside of a query renderer.", containerName, containerName) : invariant(false) : void 0;
        var queryRendererContext = useContext(ReactRelayQueryRendererContext);
        return React.createElement(Container, (0, _extends2["default"])({}, props, {
          __relayContext: context,
          __rootIsQueryRenderer: (_queryRendererContext = queryRendererContext === null || queryRendererContext === void 0 ? void 0 : queryRendererContext.rootIsQueryRenderer) !== null && _queryRendererContext !== void 0 ? _queryRendererContext : false,
          componentRef: props.componentRef || ref
        }));
      }
      ForwardRef.displayName = containerName;
      var ForwardContainer = React.forwardRef(ForwardRef);
      if (true) {
        ForwardContainer.__ComponentClass = ComponentClass;
        ForwardContainer.displayName = containerName;
      }
      return ForwardContainer;
    }
    module.exports = buildReactRelayContainer;
  }
});

// ../node_modules/react-relay/lib/isRelayEnvironment.js
var require_isRelayEnvironment = __commonJS({
  "../node_modules/react-relay/lib/isRelayEnvironment.js"(exports, module) {
    "use strict";
    function isRelayEnvironment(environment) {
      return typeof environment === "object" && environment !== null && typeof environment.check === "function" && typeof environment.lookup === "function" && typeof environment.retain === "function" && typeof environment.execute === "function" && typeof environment.subscribe === "function";
    }
    module.exports = isRelayEnvironment;
  }
});

// ../node_modules/react-relay/lib/RelayContext.js
var require_RelayContext = __commonJS({
  "../node_modules/react-relay/lib/RelayContext.js"(exports, module) {
    "use strict";
    var isRelayEnvironment = require_isRelayEnvironment();
    var invariant = require_browser();
    function assertRelayContext(relay) {
      !isRelayContext(relay) ? true ? invariant(false, "RelayContext: Expected `context.relay` to be an object conforming to the `RelayContext` interface, got `%s`.", relay) : invariant(false) : void 0;
      return relay;
    }
    function isRelayContext(context) {
      return typeof context === "object" && context !== null && !Array.isArray(context) && isRelayEnvironment(context.environment);
    }
    module.exports = {
      assertRelayContext,
      isRelayContext
    };
  }
});

// ../node_modules/react-relay/lib/ReactRelayFragmentContainer.js
var require_ReactRelayFragmentContainer = __commonJS({
  "../node_modules/react-relay/lib/ReactRelayFragmentContainer.js"(exports, module) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault()["default"];
    var _extends2 = _interopRequireDefault(require_extends());
    var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require_objectWithoutPropertiesLoose());
    var _assertThisInitialized2 = _interopRequireDefault(require_assertThisInitialized());
    var _inheritsLoose2 = _interopRequireDefault(require_inheritsLoose());
    var _defineProperty2 = _interopRequireDefault(require_defineProperty());
    var _excluded = ["componentRef", "__relayContext", "__rootIsQueryRenderer"];
    var buildReactRelayContainer = require_buildReactRelayContainer();
    var _require = require_ReactRelayContainerUtils();
    var getContainerName = _require.getContainerName;
    var _require2 = require_RelayContext();
    var assertRelayContext = _require2.assertRelayContext;
    var areEqual = require_areEqual();
    var React = require_react();
    var _require3 = require_relay_runtime();
    var createFragmentSpecResolver = _require3.createFragmentSpecResolver;
    var getDataIDsFromObject = _require3.getDataIDsFromObject;
    var isScalarAndEqual = _require3.isScalarAndEqual;
    function createContainerWithFragments(Component, fragments) {
      var _class;
      var containerName = getContainerName(Component);
      return _class = (function(_React$Component) {
        (0, _inheritsLoose2["default"])(_class2, _React$Component);
        function _class2(props) {
          var _props$__rootIsQueryR, _this;
          _this = _React$Component.call(this, props) || this;
          (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_handleFragmentDataUpdate", function() {
            var resolverFromThisUpdate = _this.state.resolver;
            _this.setState(function(updatedState) {
              return resolverFromThisUpdate === updatedState.resolver ? {
                data: updatedState.resolver.resolve(),
                relayProp: getRelayProp(updatedState.relayProp.environment)
              } : null;
            });
          });
          var relayContext = assertRelayContext(props.__relayContext);
          var rootIsQueryRenderer = (_props$__rootIsQueryR = props.__rootIsQueryRenderer) !== null && _props$__rootIsQueryR !== void 0 ? _props$__rootIsQueryR : false;
          var resolver = createFragmentSpecResolver(relayContext, containerName, fragments, props, rootIsQueryRenderer);
          _this.state = {
            data: resolver.resolve(),
            prevProps: props,
            prevPropsContext: relayContext,
            relayProp: getRelayProp(relayContext.environment),
            resolver
          };
          return _this;
        }
        _class2.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, prevState) {
          var _nextProps$__rootIsQu;
          var prevProps = prevState.prevProps;
          var relayContext = assertRelayContext(nextProps.__relayContext);
          var rootIsQueryRenderer = (_nextProps$__rootIsQu = nextProps.__rootIsQueryRenderer) !== null && _nextProps$__rootIsQu !== void 0 ? _nextProps$__rootIsQu : false;
          var prevIDs = getDataIDsFromObject(fragments, prevProps);
          var nextIDs = getDataIDsFromObject(fragments, nextProps);
          var resolver = prevState.resolver;
          if (prevState.prevPropsContext.environment !== relayContext.environment || !areEqual(prevIDs, nextIDs)) {
            resolver = createFragmentSpecResolver(relayContext, containerName, fragments, nextProps, rootIsQueryRenderer);
            return {
              data: resolver.resolve(),
              prevPropsContext: relayContext,
              prevProps: nextProps,
              relayProp: getRelayProp(relayContext.environment),
              resolver
            };
          } else {
            resolver.setProps(nextProps);
            var data = resolver.resolve();
            if (data !== prevState.data) {
              return {
                data,
                prevProps: nextProps,
                prevPropsContext: relayContext,
                relayProp: getRelayProp(relayContext.environment)
              };
            }
          }
          return null;
        };
        var _proto = _class2.prototype;
        _proto.componentDidMount = function componentDidMount() {
          this._subscribeToNewResolverAndRerenderIfStoreHasChanged();
        };
        _proto.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {
          if (this.state.resolver !== prevState.resolver) {
            prevState.resolver.dispose();
            this._subscribeToNewResolverAndRerenderIfStoreHasChanged();
          } else {
            this._rerenderIfStoreHasChanged();
          }
        };
        _proto.componentWillUnmount = function componentWillUnmount() {
          this.state.resolver.dispose();
        };
        _proto.shouldComponentUpdate = function shouldComponentUpdate(nextProps, nextState) {
          if (nextState.data !== this.state.data) {
            return true;
          }
          var keys = Object.keys(nextProps);
          for (var ii = 0; ii < keys.length; ii++) {
            var key = keys[ii];
            if (key === "__relayContext") {
              if (nextState.prevPropsContext.environment !== this.state.prevPropsContext.environment) {
                return true;
              }
            } else {
              if (!fragments.hasOwnProperty(key) && !isScalarAndEqual(nextProps[key], this.props[key])) {
                return true;
              }
            }
          }
          return false;
        };
        _proto._rerenderIfStoreHasChanged = function _rerenderIfStoreHasChanged() {
          var _this$state = this.state, data = _this$state.data, resolver = _this$state.resolver;
          var maybeNewData = resolver.resolve();
          if (data !== maybeNewData) {
            this.setState({
              data: maybeNewData
            });
          }
        };
        _proto._subscribeToNewResolverAndRerenderIfStoreHasChanged = function _subscribeToNewResolverAndRerenderIfStoreHasChanged() {
          var _this$state2 = this.state, data = _this$state2.data, resolver = _this$state2.resolver;
          var maybeNewData = resolver.resolve();
          resolver.setCallback(this.props, this._handleFragmentDataUpdate);
          if (data !== maybeNewData) {
            this.setState({
              data: maybeNewData
            });
          }
        };
        _proto.render = function render() {
          var _this$props = this.props, componentRef = _this$props.componentRef, __relayContext = _this$props.__relayContext, __rootIsQueryRenderer = _this$props.__rootIsQueryRenderer, props = (0, _objectWithoutPropertiesLoose2["default"])(_this$props, _excluded);
          return React.createElement(Component, (0, _extends2["default"])({}, props, this.state.data, {
            ref: componentRef,
            relay: this.state.relayProp
          }));
        };
        return _class2;
      })(React.Component), (0, _defineProperty2["default"])(_class, "displayName", containerName), _class;
    }
    function getRelayProp(environment) {
      return {
        environment
      };
    }
    function createContainer(Component, fragmentSpec) {
      return buildReactRelayContainer(Component, fragmentSpec, createContainerWithFragments);
    }
    module.exports = {
      createContainer
    };
  }
});

// ../node_modules/react-relay/lib/ReactRelayLocalQueryRenderer.js
var require_ReactRelayLocalQueryRenderer = __commonJS({
  "../node_modules/react-relay/lib/ReactRelayLocalQueryRenderer.js"(exports, module) {
    "use strict";
    var ReactRelayContext = require_ReactRelayContext();
    var ReactRelayQueryRendererContext = require_ReactRelayQueryRendererContext();
    var areEqual = require_areEqual();
    var React = require_react();
    var _require = require_relay_runtime();
    var createOperationDescriptor = _require.createOperationDescriptor;
    var deepFreeze = _require.deepFreeze;
    var getRequest = _require.getRequest;
    var useLayoutEffect = React.useLayoutEffect;
    var useState = React.useState;
    var useRef = React.useRef;
    var useMemo = React.useMemo;
    var queryRendererContext = {
      rootIsQueryRenderer: true
    };
    function useDeepCompare(value) {
      var latestValue = React.useRef(value);
      if (!areEqual(latestValue.current, value)) {
        if (true) {
          deepFreeze(value);
        }
        latestValue.current = value;
      }
      return latestValue.current;
    }
    function ReactRelayLocalQueryRenderer(props) {
      var environment = props.environment, query = props.query, variables = props.variables, render = props.render;
      var latestVariables = useDeepCompare(variables);
      var operation = useMemo(function() {
        var request = getRequest(query);
        return createOperationDescriptor(request, latestVariables);
      }, [query, latestVariables]);
      var relayContext = useMemo(function() {
        return {
          environment
        };
      }, [environment]);
      var dataRef = useRef(null);
      var _useState = useState(null), forceUpdate = _useState[1];
      var cleanupFnRef = useRef(null);
      var snapshot = useMemo(function() {
        environment.check(operation);
        var res = environment.lookup(operation.fragment);
        dataRef.current = res.data;
        var retainDisposable = environment.retain(operation);
        var subscribeDisposable = environment.subscribe(res, function(newSnapshot) {
          dataRef.current = newSnapshot.data;
          forceUpdate(dataRef.current);
        });
        var disposed = false;
        function nextCleanupFn() {
          if (!disposed) {
            disposed = true;
            cleanupFnRef.current = null;
            retainDisposable.dispose();
            subscribeDisposable.dispose();
          }
        }
        if (cleanupFnRef.current) {
          cleanupFnRef.current();
        }
        cleanupFnRef.current = nextCleanupFn;
        return res;
      }, [environment, operation]);
      useLayoutEffect(function() {
        var cleanupFn = cleanupFnRef.current;
        return function() {
          cleanupFn && cleanupFn();
        };
      }, [snapshot]);
      return React.createElement(ReactRelayContext.Provider, {
        value: relayContext
      }, React.createElement(ReactRelayQueryRendererContext.Provider, {
        value: queryRendererContext
      }, render({
        props: dataRef.current
      })));
    }
    module.exports = ReactRelayLocalQueryRenderer;
  }
});

// ../node_modules/react-relay/lib/getRootVariablesForFragments.js
var require_getRootVariablesForFragments = __commonJS({
  "../node_modules/react-relay/lib/getRootVariablesForFragments.js"(exports, module) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault()["default"];
    var _objectSpread2 = _interopRequireDefault(require_objectSpread2());
    var _require = require_relay_runtime();
    var getSelector = _require.getSelector;
    function getRootVariablesForFragments(fragments, props) {
      var rootVariables = {};
      Object.keys(fragments).forEach(function(key) {
        var _selector$selectors$, _selector$selectors$2, _selector$owner$varia;
        var fragmentNode = fragments[key];
        var fragmentRef = props[key];
        var selector = getSelector(fragmentNode, fragmentRef);
        var fragmentOwnerVariables = selector != null && selector.kind === "PluralReaderSelector" ? (_selector$selectors$ = (_selector$selectors$2 = selector.selectors[0]) === null || _selector$selectors$2 === void 0 ? void 0 : _selector$selectors$2.owner.variables) !== null && _selector$selectors$ !== void 0 ? _selector$selectors$ : {} : (_selector$owner$varia = selector === null || selector === void 0 ? void 0 : selector.owner.variables) !== null && _selector$owner$varia !== void 0 ? _selector$owner$varia : {};
        rootVariables = (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, rootVariables), fragmentOwnerVariables);
      });
      return rootVariables;
    }
    module.exports = getRootVariablesForFragments;
  }
});

// ../node_modules/react-relay/lib/ReactRelayQueryFetcher.js
var require_ReactRelayQueryFetcher = __commonJS({
  "../node_modules/react-relay/lib/ReactRelayQueryFetcher.js"(exports, module) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault()["default"];
    var _defineProperty2 = _interopRequireDefault(require_defineProperty());
    var invariant = require_browser();
    var _require = require_relay_runtime();
    var fetchQuery = _require.__internal.fetchQuery;
    var createOperationDescriptor = _require.createOperationDescriptor;
    var isRelayModernEnvironment = _require.isRelayModernEnvironment;
    var ReactRelayQueryFetcher = (function() {
      function ReactRelayQueryFetcher2(args) {
        (0, _defineProperty2["default"])(this, "_selectionReferences", []);
        (0, _defineProperty2["default"])(this, "_didFetchFinish", false);
        if (args != null) {
          this._cacheSelectionReference = args.cacheSelectionReference;
          this._selectionReferences = args.selectionReferences;
        }
      }
      var _proto = ReactRelayQueryFetcher2.prototype;
      _proto.getSelectionReferences = function getSelectionReferences() {
        return {
          cacheSelectionReference: this._cacheSelectionReference,
          selectionReferences: this._selectionReferences
        };
      };
      _proto.lookupInStore = function lookupInStore(environment, operation, fetchPolicy) {
        if (fetchPolicy === "store-and-network" || fetchPolicy === "store-or-network") {
          if (environment.check(operation).status === "available") {
            this._retainCachedOperation(environment, operation);
            return environment.lookup(operation.fragment);
          }
        }
        return null;
      };
      _proto.getFetchResult = function getFetchResult() {
        if (this._didFetchFinish) {
          if (this._error != null) {
            return {
              error: this._error
            };
          } else if (this._snapshot != null) {
            return {
              snapshot: this._snapshot
            };
          }
        } else {
          return null;
        }
      };
      _proto.execute = function execute(_ref) {
        var _this = this;
        var environment = _ref.environment, operation = _ref.operation, _ref$preservePrevious = _ref.preservePreviousReferences, preservePreviousReferences = _ref$preservePrevious === void 0 ? false : _ref$preservePrevious;
        var reference = environment.retain(operation);
        var error = function error2() {
          _this._selectionReferences = _this._selectionReferences.concat(reference);
        };
        var complete = function complete2() {
          if (!preservePreviousReferences) {
            _this.disposeSelectionReferences();
          }
          _this._selectionReferences = _this._selectionReferences.concat(reference);
        };
        var unsubscribe = function unsubscribe2() {
          _this._selectionReferences = _this._selectionReferences.concat(reference);
        };
        if (!isRelayModernEnvironment(environment)) {
          return environment.execute({
            operation
          })["do"]({
            error,
            complete,
            unsubscribe
          });
        }
        return fetchQuery(environment, operation)["do"]({
          error,
          complete,
          unsubscribe
        });
      };
      _proto.setOnDataChange = function setOnDataChange(onDataChange) {
        !this._fetchOptions ? true ? invariant(false, "ReactRelayQueryFetcher: `setOnDataChange` should have been called after having called `fetch`") : invariant(false) : void 0;
        if (typeof onDataChange === "function") {
          this._fetchOptions.onDataChangeCallbacks = this._fetchOptions.onDataChangeCallbacks || [];
          this._fetchOptions.onDataChangeCallbacks.push(onDataChange);
          if (this._didFetchFinish) {
            if (this._error != null) {
              onDataChange({
                error: this._error
              });
            } else if (this._snapshot != null) {
              onDataChange({
                snapshot: this._snapshot
              });
            }
          }
        }
      };
      _proto.fetch = function fetch(fetchOptions, cacheConfigOverride) {
        var _this2 = this;
        var environment = fetchOptions.environment, operation = fetchOptions.operation, onDataChange = fetchOptions.onDataChange;
        var fetchHasReturned = false;
        var _error;
        this.disposeRequest();
        var oldOnDataChangeCallbacks = this._fetchOptions && this._fetchOptions.onDataChangeCallbacks;
        this._fetchOptions = {
          environment,
          onDataChangeCallbacks: oldOnDataChangeCallbacks || [],
          operation
        };
        if (onDataChange && this._fetchOptions.onDataChangeCallbacks.indexOf(onDataChange) === -1) {
          this._fetchOptions.onDataChangeCallbacks.push(onDataChange);
        }
        var operationOverride = cacheConfigOverride ? createOperationDescriptor(operation.request.node, operation.request.variables, cacheConfigOverride) : operation;
        var request = this.execute({
          environment,
          operation: operationOverride
        })["finally"](function() {
          _this2._pendingRequest = null;
        }).subscribe({
          next: function next() {
            _this2._didFetchFinish = true;
            _this2._error = null;
            _this2._onQueryDataAvailable({
              notifyFirstResult: fetchHasReturned
            });
          },
          error: function error(err) {
            _this2._didFetchFinish = true;
            _this2._error = err;
            _this2._snapshot = null;
            var onDataChangeCallbacks = _this2._fetchOptions && _this2._fetchOptions.onDataChangeCallbacks;
            if (fetchHasReturned) {
              if (onDataChangeCallbacks) {
                onDataChangeCallbacks.forEach(function(onDataChange2) {
                  onDataChange2({
                    error: err
                  });
                });
              }
            } else {
              _error = err;
            }
          }
        });
        this._pendingRequest = {
          dispose: function dispose() {
            request.unsubscribe();
          }
        };
        fetchHasReturned = true;
        if (_error) {
          throw _error;
        }
        return this._snapshot;
      };
      _proto.retry = function retry(cacheConfigOverride) {
        !this._fetchOptions ? true ? invariant(false, "ReactRelayQueryFetcher: `retry` should be called after having called `fetch`") : invariant(false) : void 0;
        return this.fetch({
          environment: this._fetchOptions.environment,
          operation: this._fetchOptions.operation,
          onDataChange: null
        }, cacheConfigOverride);
      };
      _proto.dispose = function dispose() {
        this.disposeRequest();
        this.disposeSelectionReferences();
      };
      _proto.disposeRequest = function disposeRequest() {
        this._error = null;
        this._snapshot = null;
        if (this._pendingRequest) {
          this._pendingRequest.dispose();
        }
        if (this._rootSubscription) {
          this._rootSubscription.dispose();
          this._rootSubscription = null;
        }
      };
      _proto._retainCachedOperation = function _retainCachedOperation(environment, operation) {
        this._disposeCacheSelectionReference();
        this._cacheSelectionReference = environment.retain(operation);
      };
      _proto._disposeCacheSelectionReference = function _disposeCacheSelectionReference() {
        this._cacheSelectionReference && this._cacheSelectionReference.dispose();
        this._cacheSelectionReference = null;
      };
      _proto.disposeSelectionReferences = function disposeSelectionReferences() {
        this._disposeCacheSelectionReference();
        this._selectionReferences.forEach(function(r) {
          return r.dispose();
        });
        this._selectionReferences = [];
      };
      _proto._onQueryDataAvailable = function _onQueryDataAvailable(_ref2) {
        var _this3 = this;
        var notifyFirstResult = _ref2.notifyFirstResult;
        !this._fetchOptions ? true ? invariant(false, "ReactRelayQueryFetcher: `_onQueryDataAvailable` should have been called after having called `fetch`") : invariant(false) : void 0;
        var _this$_fetchOptions = this._fetchOptions, environment = _this$_fetchOptions.environment, onDataChangeCallbacks = _this$_fetchOptions.onDataChangeCallbacks, operation = _this$_fetchOptions.operation;
        if (this._snapshot) {
          return;
        }
        this._snapshot = environment.lookup(operation.fragment);
        this._rootSubscription = environment.subscribe(this._snapshot, function(snapshot2) {
          if (_this3._fetchOptions != null) {
            var maybeNewOnDataChangeCallbacks = _this3._fetchOptions.onDataChangeCallbacks;
            if (Array.isArray(maybeNewOnDataChangeCallbacks)) {
              maybeNewOnDataChangeCallbacks.forEach(function(onDataChange) {
                return onDataChange({
                  snapshot: snapshot2
                });
              });
            }
          }
        });
        if (this._snapshot && notifyFirstResult && Array.isArray(onDataChangeCallbacks)) {
          var snapshot = this._snapshot;
          onDataChangeCallbacks.forEach(function(onDataChange) {
            return onDataChange({
              snapshot
            });
          });
        }
      };
      return ReactRelayQueryFetcher2;
    })();
    module.exports = ReactRelayQueryFetcher;
  }
});

// ../node_modules/react-relay/lib/ReactRelayPaginationContainer.js
var require_ReactRelayPaginationContainer = __commonJS({
  "../node_modules/react-relay/lib/ReactRelayPaginationContainer.js"(exports, module) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault()["default"];
    var _extends2 = _interopRequireDefault(require_extends());
    var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require_objectWithoutPropertiesLoose());
    var _assertThisInitialized2 = _interopRequireDefault(require_assertThisInitialized());
    var _inheritsLoose2 = _interopRequireDefault(require_inheritsLoose());
    var _defineProperty2 = _interopRequireDefault(require_defineProperty());
    var _objectSpread3 = _interopRequireDefault(require_objectSpread2());
    var _excluded = ["componentRef"];
    var _excluded2 = ["componentRef", "__relayContext", "__rootIsQueryRenderer"];
    var _excluded3 = ["componentRef", "__relayContext", "__rootIsQueryRenderer"];
    var buildReactRelayContainer = require_buildReactRelayContainer();
    var getRootVariablesForFragments = require_getRootVariablesForFragments();
    var _require = require_ReactRelayContainerUtils();
    var getComponentName = _require.getComponentName;
    var getContainerName = _require.getContainerName;
    var ReactRelayContext = require_ReactRelayContext();
    var ReactRelayQueryFetcher = require_ReactRelayQueryFetcher();
    var _require2 = require_RelayContext();
    var assertRelayContext = _require2.assertRelayContext;
    var areEqual = require_areEqual();
    var invariant = require_browser();
    var React = require_react();
    var _require3 = require_relay_runtime();
    var ConnectionInterface = _require3.ConnectionInterface;
    var Observable = _require3.Observable;
    var RelayFeatureFlags = _require3.RelayFeatureFlags;
    var createFragmentSpecResolver = _require3.createFragmentSpecResolver;
    var createOperationDescriptor = _require3.createOperationDescriptor;
    var getDataIDsFromObject = _require3.getDataIDsFromObject;
    var getRequest = _require3.getRequest;
    var getVariablesFromObject = _require3.getVariablesFromObject;
    var isScalarAndEqual = _require3.isScalarAndEqual;
    var warning = require_warning();
    var FORWARD = "forward";
    function createGetConnectionFromProps(metadata) {
      var path = metadata.path;
      !path ? true ? invariant(false, "ReactRelayPaginationContainer: Unable to synthesize a getConnectionFromProps function.") : invariant(false) : void 0;
      return function(props) {
        var data = props[metadata.fragmentName];
        for (var i = 0; i < path.length; i++) {
          if (!data || typeof data !== "object") {
            return null;
          }
          data = data[path[i]];
        }
        return data;
      };
    }
    function createGetFragmentVariables(metadata) {
      var countVariable = metadata.count;
      !countVariable ? true ? invariant(false, "ReactRelayPaginationContainer: Unable to synthesize a getFragmentVariables function.") : invariant(false) : void 0;
      return function(prevVars, totalCount) {
        return (0, _objectSpread3["default"])((0, _objectSpread3["default"])({}, prevVars), {}, (0, _defineProperty2["default"])({}, countVariable, totalCount));
      };
    }
    function findConnectionMetadata(fragments) {
      var foundConnectionMetadata = null;
      var isRelayModern = false;
      for (var fragmentName in fragments) {
        var fragment = fragments[fragmentName];
        var connectionMetadata = fragment.metadata && fragment.metadata.connection;
        if (fragment.metadata !== void 0) {
          isRelayModern = true;
        }
        if (connectionMetadata) {
          !(connectionMetadata.length === 1) ? true ? invariant(false, "ReactRelayPaginationContainer: Only a single @connection is supported, `%s` has %s.", fragmentName, connectionMetadata.length) : invariant(false) : void 0;
          !!foundConnectionMetadata ? true ? invariant(false, "ReactRelayPaginationContainer: Only a single fragment with @connection is supported.") : invariant(false) : void 0;
          foundConnectionMetadata = (0, _objectSpread3["default"])((0, _objectSpread3["default"])({}, connectionMetadata[0]), {}, {
            fragmentName
          });
        }
      }
      !(!isRelayModern || foundConnectionMetadata !== null) ? true ? invariant(false, "ReactRelayPaginationContainer: A @connection directive must be present.") : invariant(false) : void 0;
      return foundConnectionMetadata || {};
    }
    function toObserver(observerOrCallback) {
      return typeof observerOrCallback === "function" ? {
        error: observerOrCallback,
        complete: observerOrCallback,
        unsubscribe: function unsubscribe(subscription) {
          typeof observerOrCallback === "function" && observerOrCallback();
        }
      } : observerOrCallback || {};
    }
    function createContainerWithFragments(Component, fragments, connectionConfig) {
      var _class;
      var componentName = getComponentName(Component);
      var containerName = getContainerName(Component);
      var metadata = findConnectionMetadata(fragments);
      var getConnectionFromProps = connectionConfig.getConnectionFromProps || createGetConnectionFromProps(metadata);
      var direction = connectionConfig.direction || metadata.direction;
      !direction ? true ? invariant(false, "ReactRelayPaginationContainer: Unable to infer direction of the connection, possibly because both first and last are provided.") : invariant(false) : void 0;
      var getFragmentVariables = connectionConfig.getFragmentVariables || createGetFragmentVariables(metadata);
      return _class = (function(_React$Component) {
        (0, _inheritsLoose2["default"])(_class2, _React$Component);
        function _class2(props) {
          var _props$__rootIsQueryR, _this;
          _this = _React$Component.call(this, props) || this;
          (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_handleFragmentDataUpdate", function() {
            _this.setState({
              data: _this._resolver.resolve()
            });
          });
          (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_hasMore", function() {
            var connectionData = _this._getConnectionData();
            return !!(connectionData && connectionData.hasMore && connectionData.cursor);
          });
          (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_isLoading", function() {
            return !!_this._refetchSubscription;
          });
          (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_refetchConnection", function(totalCount, observerOrCallback, refetchVariables) {
            if (!_this._canFetchPage("refetchConnection")) {
              return {
                dispose: function dispose() {
                }
              };
            }
            _this._refetchVariables = refetchVariables;
            var paginatingVariables = {
              count: totalCount,
              cursor: null,
              totalCount
            };
            var fetch = _this._fetchPage(paginatingVariables, toObserver(observerOrCallback), {
              force: true
            });
            return {
              dispose: fetch.unsubscribe
            };
          });
          (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_loadMore", function(pageSize, observerOrCallback, options) {
            if (!_this._canFetchPage("loadMore")) {
              return {
                dispose: function dispose() {
                }
              };
            }
            var observer = toObserver(observerOrCallback);
            var connectionData = _this._getConnectionData();
            if (!connectionData) {
              Observable.create(function(sink) {
                return sink.complete();
              }).subscribe(observer);
              return null;
            }
            var totalCount = connectionData.edgeCount + pageSize;
            if (options && options.force) {
              return _this._refetchConnection(totalCount, observerOrCallback);
            }
            var _ConnectionInterface$ = ConnectionInterface.get(), END_CURSOR = _ConnectionInterface$.END_CURSOR, START_CURSOR = _ConnectionInterface$.START_CURSOR;
            var cursor = connectionData.cursor;
            true ? warning(cursor != null && cursor !== "", "ReactRelayPaginationContainer: Cannot `loadMore` without valid `%s` (got `%s`)", direction === FORWARD ? END_CURSOR : START_CURSOR, cursor) : void 0;
            var paginatingVariables = {
              count: pageSize,
              cursor,
              totalCount
            };
            var fetch = _this._fetchPage(paginatingVariables, observer, options);
            return {
              dispose: fetch.unsubscribe
            };
          });
          var relayContext = assertRelayContext(props.__relayContext);
          var rootIsQueryRenderer = (_props$__rootIsQueryR = props.__rootIsQueryRenderer) !== null && _props$__rootIsQueryR !== void 0 ? _props$__rootIsQueryR : false;
          _this._isARequestInFlight = false;
          _this._refetchSubscription = null;
          _this._refetchVariables = null;
          if (RelayFeatureFlags.ENABLE_CONTAINERS_SUBSCRIBE_ON_COMMIT === true) {
            _this._resolver = createFragmentSpecResolver(relayContext, containerName, fragments, props, rootIsQueryRenderer);
          } else {
            _this._resolver = createFragmentSpecResolver(relayContext, containerName, fragments, props, rootIsQueryRenderer, _this._handleFragmentDataUpdate);
          }
          _this.state = {
            data: _this._resolver.resolve(),
            prevContext: relayContext,
            contextForChildren: relayContext,
            relayProp: _this._buildRelayProp(relayContext),
            resolverGeneration: 0
          };
          _this._isUnmounted = false;
          _this._hasFetched = false;
          return _this;
        }
        var _proto = _class2.prototype;
        _proto.componentDidMount = function componentDidMount() {
          this._isUnmounted = false;
          if (RelayFeatureFlags.ENABLE_CONTAINERS_SUBSCRIBE_ON_COMMIT === true) {
            this._subscribeToNewResolverAndRerenderIfStoreHasChanged();
          }
        };
        _proto.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {
          if (RelayFeatureFlags.ENABLE_CONTAINERS_SUBSCRIBE_ON_COMMIT === true) {
            if (prevState.resolverGeneration !== this.state.resolverGeneration) {
              this._subscribeToNewResolverAndRerenderIfStoreHasChanged();
            } else {
              this._rerenderIfStoreHasChanged();
            }
          }
        };
        _proto.UNSAFE_componentWillReceiveProps = function UNSAFE_componentWillReceiveProps(nextProps) {
          var _this2 = this;
          var _nextProps$__rootIsQu;
          var relayContext = assertRelayContext(nextProps.__relayContext);
          var rootIsQueryRenderer = (_nextProps$__rootIsQu = nextProps.__rootIsQueryRenderer) !== null && _nextProps$__rootIsQu !== void 0 ? _nextProps$__rootIsQu : false;
          var prevIDs = getDataIDsFromObject(fragments, this.props);
          var nextIDs = getDataIDsFromObject(fragments, nextProps);
          var prevRootVariables = getRootVariablesForFragments(fragments, this.props);
          var nextRootVariables = getRootVariablesForFragments(fragments, nextProps);
          if (relayContext.environment !== this.state.prevContext.environment || !areEqual(prevRootVariables, nextRootVariables) || !areEqual(prevIDs, nextIDs)) {
            this._cleanup();
            if (RelayFeatureFlags.ENABLE_CONTAINERS_SUBSCRIBE_ON_COMMIT === true) {
              this._resolver = createFragmentSpecResolver(relayContext, containerName, fragments, nextProps, rootIsQueryRenderer);
            } else {
              this._resolver = createFragmentSpecResolver(relayContext, containerName, fragments, nextProps, rootIsQueryRenderer, this._handleFragmentDataUpdate);
            }
            this.setState(function(prevState) {
              return {
                prevContext: relayContext,
                contextForChildren: relayContext,
                relayProp: _this2._buildRelayProp(relayContext),
                resolverGeneration: prevState.resolverGeneration + 1
              };
            });
          } else if (!this._hasFetched) {
            this._resolver.setProps(nextProps);
          }
          var data = this._resolver.resolve();
          if (data !== this.state.data) {
            this.setState({
              data
            });
          }
        };
        _proto.componentWillUnmount = function componentWillUnmount() {
          this._isUnmounted = true;
          this._cleanup();
        };
        _proto.shouldComponentUpdate = function shouldComponentUpdate(nextProps, nextState) {
          if (nextState.data !== this.state.data || nextState.relayProp !== this.state.relayProp || nextState.resolverGeneration !== this.state.resolverGeneration) {
            return true;
          }
          var keys = Object.keys(nextProps);
          for (var ii = 0; ii < keys.length; ii++) {
            var key = keys[ii];
            if (key === "__relayContext") {
              if (nextState.prevContext.environment !== this.state.prevContext.environment) {
                return true;
              }
            } else {
              if (!fragments.hasOwnProperty(key) && !isScalarAndEqual(nextProps[key], this.props[key])) {
                return true;
              }
            }
          }
          return false;
        };
        _proto._buildRelayProp = function _buildRelayProp(relayContext) {
          return {
            hasMore: this._hasMore,
            isLoading: this._isLoading,
            loadMore: this._loadMore,
            refetchConnection: this._refetchConnection,
            environment: relayContext.environment
          };
        };
        _proto._rerenderIfStoreHasChanged = function _rerenderIfStoreHasChanged() {
          var data = this.state.data;
          var maybeNewData = this._resolver.resolve();
          if (data !== maybeNewData) {
            this.setState({
              data: maybeNewData
            });
          }
        };
        _proto._subscribeToNewResolverAndRerenderIfStoreHasChanged = function _subscribeToNewResolverAndRerenderIfStoreHasChanged() {
          var data = this.state.data;
          var maybeNewData = this._resolver.resolve();
          this._resolver.setCallback(this.props, this._handleFragmentDataUpdate);
          if (data !== maybeNewData) {
            this.setState({
              data: maybeNewData
            });
          }
        };
        _proto._getConnectionData = function _getConnectionData() {
          var _this$props = this.props, _ = _this$props.componentRef, restProps = (0, _objectWithoutPropertiesLoose2["default"])(_this$props, _excluded);
          var props = (0, _objectSpread3["default"])((0, _objectSpread3["default"])({}, restProps), this.state.data);
          var connectionData = getConnectionFromProps(props);
          if (connectionData == null) {
            return null;
          }
          var _ConnectionInterface$2 = ConnectionInterface.get(), EDGES = _ConnectionInterface$2.EDGES, PAGE_INFO = _ConnectionInterface$2.PAGE_INFO, HAS_NEXT_PAGE = _ConnectionInterface$2.HAS_NEXT_PAGE, HAS_PREV_PAGE = _ConnectionInterface$2.HAS_PREV_PAGE, END_CURSOR = _ConnectionInterface$2.END_CURSOR, START_CURSOR = _ConnectionInterface$2.START_CURSOR;
          !(typeof connectionData === "object") ? true ? invariant(false, "ReactRelayPaginationContainer: Expected `getConnectionFromProps()` in `%s`to return `null` or a plain object with %s and %s properties, got `%s`.", componentName, EDGES, PAGE_INFO, connectionData) : invariant(false) : void 0;
          var edges = connectionData[EDGES];
          var pageInfo = connectionData[PAGE_INFO];
          if (edges == null || pageInfo == null) {
            return null;
          }
          !Array.isArray(edges) ? true ? invariant(false, "ReactRelayPaginationContainer: Expected `getConnectionFromProps()` in `%s`to return an object with %s: Array, got `%s`.", componentName, EDGES, edges) : invariant(false) : void 0;
          !(typeof pageInfo === "object") ? true ? invariant(false, "ReactRelayPaginationContainer: Expected `getConnectionFromProps()` in `%s`to return an object with %s: Object, got `%s`.", componentName, PAGE_INFO, pageInfo) : invariant(false) : void 0;
          var hasMore = direction === FORWARD ? pageInfo[HAS_NEXT_PAGE] : pageInfo[HAS_PREV_PAGE];
          var cursor = direction === FORWARD ? pageInfo[END_CURSOR] : pageInfo[START_CURSOR];
          if (typeof hasMore !== "boolean" || edges.length !== 0 && typeof cursor === "undefined") {
            true ? warning(false, "ReactRelayPaginationContainer: Cannot paginate without %s fields in `%s`. Be sure to fetch %s (got `%s`) and %s (got `%s`).", PAGE_INFO, componentName, direction === FORWARD ? HAS_NEXT_PAGE : HAS_PREV_PAGE, hasMore, direction === FORWARD ? END_CURSOR : START_CURSOR, cursor) : void 0;
            return null;
          }
          return {
            cursor,
            edgeCount: edges.length,
            hasMore
          };
        };
        _proto._getQueryFetcher = function _getQueryFetcher() {
          if (!this._queryFetcher) {
            this._queryFetcher = new ReactRelayQueryFetcher();
          }
          return this._queryFetcher;
        };
        _proto._canFetchPage = function _canFetchPage(method) {
          if (this._isUnmounted) {
            true ? warning(false, "ReactRelayPaginationContainer: Unexpected call of `%s` on unmounted container `%s`. It looks like some instances of your container still trying to fetch data but they already unmounted. Please make sure you clear all timers, intervals, async calls, etc that may trigger `%s` call.", method, containerName, method) : void 0;
            return false;
          }
          return true;
        };
        _proto._fetchPage = function _fetchPage(paginatingVariables, observer, options) {
          var _this3 = this;
          var _assertRelayContext = assertRelayContext(this.props.__relayContext), environment = _assertRelayContext.environment;
          var _this$props2 = this.props, _ = _this$props2.componentRef, __relayContext = _this$props2.__relayContext, __rootIsQueryRenderer = _this$props2.__rootIsQueryRenderer, restProps = (0, _objectWithoutPropertiesLoose2["default"])(_this$props2, _excluded2);
          var props = (0, _objectSpread3["default"])((0, _objectSpread3["default"])({}, restProps), this.state.data);
          var fragmentVariables;
          var rootVariables = getRootVariablesForFragments(fragments, restProps);
          fragmentVariables = getVariablesFromObject(fragments, restProps);
          fragmentVariables = (0, _objectSpread3["default"])((0, _objectSpread3["default"])((0, _objectSpread3["default"])({}, rootVariables), fragmentVariables), this._refetchVariables);
          var fetchVariables = connectionConfig.getVariables(props, {
            count: paginatingVariables.count,
            cursor: paginatingVariables.cursor
          }, fragmentVariables);
          !(typeof fetchVariables === "object" && fetchVariables !== null) ? true ? invariant(false, "ReactRelayPaginationContainer: Expected `getVariables()` to return an object, got `%s` in `%s`.", fetchVariables, componentName) : invariant(false) : void 0;
          fetchVariables = (0, _objectSpread3["default"])((0, _objectSpread3["default"])({}, fetchVariables), this._refetchVariables);
          fragmentVariables = (0, _objectSpread3["default"])((0, _objectSpread3["default"])({}, fetchVariables), fragmentVariables);
          var cacheConfig = options ? {
            force: !!options.force
          } : void 0;
          if (cacheConfig != null && (options === null || options === void 0 ? void 0 : options.metadata) != null) {
            cacheConfig.metadata = options === null || options === void 0 ? void 0 : options.metadata;
          }
          var request = getRequest(connectionConfig.query);
          var operation = createOperationDescriptor(request, fetchVariables, cacheConfig);
          var refetchSubscription = null;
          if (this._refetchSubscription) {
            this._refetchSubscription.unsubscribe();
          }
          this._hasFetched = true;
          var onNext = function onNext2(payload, complete) {
            var prevData = _this3._resolver.resolve();
            _this3._resolver.setVariables(getFragmentVariables(fragmentVariables, paginatingVariables.totalCount), operation.request.node);
            var nextData = _this3._resolver.resolve();
            if (!areEqual(prevData, nextData)) {
              _this3.setState({
                data: nextData,
                contextForChildren: {
                  environment: _this3.props.__relayContext.environment
                }
              }, complete);
            } else {
              complete();
            }
          };
          var cleanup = function cleanup2() {
            if (_this3._refetchSubscription === refetchSubscription) {
              _this3._refetchSubscription = null;
              _this3._isARequestInFlight = false;
            }
          };
          this._isARequestInFlight = true;
          refetchSubscription = this._getQueryFetcher().execute({
            environment,
            operation,
            preservePreviousReferences: true
          }).mergeMap(function(payload) {
            return Observable.create(function(sink) {
              onNext(payload, function() {
                sink.next();
                sink.complete();
              });
            });
          })["do"]({
            error: cleanup,
            complete: cleanup,
            unsubscribe: cleanup
          }).subscribe(observer || {});
          this._refetchSubscription = this._isARequestInFlight ? refetchSubscription : null;
          return refetchSubscription;
        };
        _proto._cleanup = function _cleanup() {
          this._resolver.dispose();
          this._refetchVariables = null;
          this._hasFetched = false;
          if (this._refetchSubscription) {
            this._refetchSubscription.unsubscribe();
            this._refetchSubscription = null;
            this._isARequestInFlight = false;
          }
          if (this._queryFetcher) {
            this._queryFetcher.dispose();
          }
        };
        _proto.render = function render() {
          var _this$props3 = this.props, componentRef = _this$props3.componentRef, __relayContext = _this$props3.__relayContext, __rootIsQueryRenderer = _this$props3.__rootIsQueryRenderer, props = (0, _objectWithoutPropertiesLoose2["default"])(_this$props3, _excluded3);
          return React.createElement(ReactRelayContext.Provider, {
            value: this.state.contextForChildren
          }, React.createElement(Component, (0, _extends2["default"])({}, props, this.state.data, {
            ref: componentRef,
            relay: this.state.relayProp
          })));
        };
        return _class2;
      })(React.Component), (0, _defineProperty2["default"])(_class, "displayName", containerName), _class;
    }
    function createContainer(Component, fragmentSpec, connectionConfig) {
      return buildReactRelayContainer(Component, fragmentSpec, function(ComponentClass, fragments) {
        return createContainerWithFragments(ComponentClass, fragments, connectionConfig);
      });
    }
    module.exports = {
      createContainer
    };
  }
});

// ../node_modules/react-relay/lib/ReactRelayQueryRenderer.js
var require_ReactRelayQueryRenderer = __commonJS({
  "../node_modules/react-relay/lib/ReactRelayQueryRenderer.js"(exports, module) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault()["default"];
    var _objectSpread2 = _interopRequireDefault(require_objectSpread2());
    var _assertThisInitialized2 = _interopRequireDefault(require_assertThisInitialized());
    var _inheritsLoose2 = _interopRequireDefault(require_inheritsLoose());
    var _defineProperty2 = _interopRequireDefault(require_defineProperty());
    var ReactRelayContext = require_ReactRelayContext();
    var ReactRelayQueryFetcher = require_ReactRelayQueryFetcher();
    var ReactRelayQueryRendererContext = require_ReactRelayQueryRendererContext();
    var areEqual = require_areEqual();
    var React = require_react();
    var _require = require_relay_runtime();
    var createOperationDescriptor = _require.createOperationDescriptor;
    var deepFreeze = _require.deepFreeze;
    var getRequest = _require.getRequest;
    var requestCache = {};
    var queryRendererContext = {
      rootIsQueryRenderer: true
    };
    var ReactRelayQueryRenderer = (function(_React$Component) {
      (0, _inheritsLoose2["default"])(ReactRelayQueryRenderer2, _React$Component);
      function ReactRelayQueryRenderer2(props) {
        var _this;
        _this = _React$Component.call(this, props) || this;
        (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_handleDataChange", function(params) {
          var error = params.error == null ? null : params.error;
          var snapshot = params.snapshot == null ? null : params.snapshot;
          _this.setState(function(prevState) {
            var prevRequestCacheKey = prevState.requestCacheKey;
            if (prevRequestCacheKey) {
              delete requestCache[prevRequestCacheKey];
            }
            if (snapshot === prevState.snapshot && error === prevState.error) {
              return null;
            }
            return {
              renderProps: getRenderProps(error, snapshot, prevState.queryFetcher, prevState.retryCallbacks),
              snapshot,
              requestCacheKey: null
            };
          });
        });
        var retryCallbacks = {
          handleDataChange: null,
          handleRetryAfterError: null
        };
        var queryFetcher;
        var requestCacheKey;
        if (props.query) {
          var query = props.query;
          var request = getRequest(query);
          requestCacheKey = getRequestCacheKey(request.params, props.variables);
          queryFetcher = requestCache[requestCacheKey] ? requestCache[requestCacheKey].queryFetcher : new ReactRelayQueryFetcher();
        } else {
          queryFetcher = new ReactRelayQueryFetcher();
        }
        _this._maybeHiddenOrFastRefresh = false;
        _this.state = (0, _objectSpread2["default"])({
          prevPropsEnvironment: props.environment,
          prevPropsVariables: props.variables,
          prevQuery: props.query,
          queryFetcher,
          retryCallbacks
        }, fetchQueryAndComputeStateFromProps(props, queryFetcher, retryCallbacks, requestCacheKey));
        return _this;
      }
      ReactRelayQueryRenderer2.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, prevState) {
        if (prevState.prevQuery !== nextProps.query || prevState.prevPropsEnvironment !== nextProps.environment || !areEqual(prevState.prevPropsVariables, nextProps.variables)) {
          return resetQueryStateForUpdate(nextProps, prevState);
        }
        return null;
      };
      var _proto = ReactRelayQueryRenderer2.prototype;
      _proto.componentDidMount = function componentDidMount() {
        var _this2 = this;
        if (this._maybeHiddenOrFastRefresh === true) {
          this._maybeHiddenOrFastRefresh = false;
          this.setState(function(prevState) {
            var newState = resetQueryStateForUpdate(_this2.props, prevState);
            var requestCacheKey2 = newState.requestCacheKey, queryFetcher2 = newState.queryFetcher;
            if (requestCacheKey2 != null && requestCache[requestCacheKey2] != null) {
              queryFetcher2.setOnDataChange(_this2._handleDataChange);
            }
            return newState;
          });
          return;
        }
        var _this$state = this.state, retryCallbacks = _this$state.retryCallbacks, queryFetcher = _this$state.queryFetcher, requestCacheKey = _this$state.requestCacheKey;
        if (requestCacheKey) {
          delete requestCache[requestCacheKey];
        }
        retryCallbacks.handleDataChange = this._handleDataChange;
        retryCallbacks.handleRetryAfterError = function(error) {
          return _this2.setState(function(prevState) {
            var prevRequestCacheKey = prevState.requestCacheKey;
            if (prevRequestCacheKey) {
              delete requestCache[prevRequestCacheKey];
            }
            return {
              renderProps: getLoadingRenderProps(),
              requestCacheKey: null
            };
          });
        };
        if (this.props.query) {
          queryFetcher.setOnDataChange(this._handleDataChange);
        }
      };
      _proto.componentDidUpdate = function componentDidUpdate(_prevProps, prevState) {
        var _this$state2 = this.state, queryFetcher = _this$state2.queryFetcher, requestCacheKey = _this$state2.requestCacheKey;
        if (requestCacheKey) {
          delete requestCache[requestCacheKey];
          delete this.state.requestCacheKey;
        }
        if (this.props.query && queryFetcher !== prevState.queryFetcher) {
          queryFetcher.setOnDataChange(this._handleDataChange);
        }
      };
      _proto.componentWillUnmount = function componentWillUnmount() {
        this.state.queryFetcher.dispose();
        this._maybeHiddenOrFastRefresh = true;
      };
      _proto.shouldComponentUpdate = function shouldComponentUpdate(nextProps, nextState) {
        return nextProps.render !== this.props.render || nextState.renderProps !== this.state.renderProps;
      };
      _proto.render = function render() {
        var _this$state3 = this.state, renderProps = _this$state3.renderProps, relayContext = _this$state3.relayContext;
        if (true) {
          deepFreeze(renderProps);
        }
        return React.createElement(ReactRelayContext.Provider, {
          value: relayContext
        }, React.createElement(ReactRelayQueryRendererContext.Provider, {
          value: queryRendererContext
        }, this.props.render(renderProps)));
      };
      return ReactRelayQueryRenderer2;
    })(React.Component);
    function getLoadingRenderProps() {
      return {
        error: null,
        props: null,
        retry: null
      };
    }
    function getEmptyRenderProps() {
      return {
        error: null,
        props: {},
        retry: null
      };
    }
    function getRenderProps(error, snapshot, queryFetcher, retryCallbacks) {
      return {
        error: error ? error : null,
        props: snapshot ? snapshot.data : null,
        retry: function retry(cacheConfigOverride) {
          var syncSnapshot = queryFetcher.retry(cacheConfigOverride);
          if (syncSnapshot && typeof retryCallbacks.handleDataChange === "function") {
            retryCallbacks.handleDataChange({
              snapshot: syncSnapshot
            });
          } else if (error && typeof retryCallbacks.handleRetryAfterError === "function") {
            retryCallbacks.handleRetryAfterError(error);
          }
        }
      };
    }
    function getRequestCacheKey(request, variables) {
      return JSON.stringify({
        id: request.cacheID ? request.cacheID : request.id,
        variables
      });
    }
    function resetQueryStateForUpdate(props, prevState) {
      var query = props.query;
      var prevSelectionReferences = prevState.queryFetcher.getSelectionReferences();
      prevState.queryFetcher.disposeRequest();
      var queryFetcher;
      if (query) {
        var request = getRequest(query);
        var requestCacheKey = getRequestCacheKey(request.params, props.variables);
        queryFetcher = requestCache[requestCacheKey] ? requestCache[requestCacheKey].queryFetcher : new ReactRelayQueryFetcher(prevSelectionReferences);
      } else {
        queryFetcher = new ReactRelayQueryFetcher(prevSelectionReferences);
      }
      return (0, _objectSpread2["default"])({
        prevQuery: props.query,
        prevPropsEnvironment: props.environment,
        prevPropsVariables: props.variables,
        queryFetcher
      }, fetchQueryAndComputeStateFromProps(props, queryFetcher, prevState.retryCallbacks));
    }
    function fetchQueryAndComputeStateFromProps(props, queryFetcher, retryCallbacks, requestCacheKey) {
      var environment = props.environment, query = props.query, variables = props.variables, cacheConfig = props.cacheConfig;
      var genericEnvironment = environment;
      if (query) {
        var request = getRequest(query);
        var operation = createOperationDescriptor(request, variables, cacheConfig);
        var relayContext = {
          environment: genericEnvironment
        };
        if (typeof requestCacheKey === "string" && requestCache[requestCacheKey]) {
          var snapshot = requestCache[requestCacheKey].snapshot;
          if (snapshot) {
            return {
              error: null,
              relayContext,
              renderProps: getRenderProps(null, snapshot, queryFetcher, retryCallbacks),
              snapshot,
              requestCacheKey
            };
          } else {
            return {
              error: null,
              relayContext,
              renderProps: getLoadingRenderProps(),
              snapshot: null,
              requestCacheKey
            };
          }
        }
        try {
          var storeSnapshot = queryFetcher.lookupInStore(genericEnvironment, operation, props.fetchPolicy);
          var querySnapshot = queryFetcher.fetch({
            environment: genericEnvironment,
            onDataChange: null,
            operation
          });
          var _snapshot = querySnapshot || storeSnapshot;
          requestCacheKey = requestCacheKey || getRequestCacheKey(request.params, props.variables);
          requestCache[requestCacheKey] = {
            queryFetcher,
            snapshot: _snapshot
          };
          if (!_snapshot) {
            return {
              error: null,
              relayContext,
              renderProps: getLoadingRenderProps(),
              snapshot: null,
              requestCacheKey
            };
          }
          return {
            error: null,
            relayContext,
            renderProps: getRenderProps(null, _snapshot, queryFetcher, retryCallbacks),
            snapshot: _snapshot,
            requestCacheKey
          };
        } catch (error) {
          return {
            error,
            relayContext,
            renderProps: getRenderProps(error, null, queryFetcher, retryCallbacks),
            snapshot: null,
            requestCacheKey
          };
        }
      } else {
        queryFetcher.dispose();
        var _relayContext = {
          environment: genericEnvironment
        };
        return {
          error: null,
          relayContext: _relayContext,
          renderProps: getEmptyRenderProps(),
          requestCacheKey: null
        };
      }
    }
    module.exports = ReactRelayQueryRenderer;
  }
});

// ../node_modules/react-relay/lib/ReactRelayRefetchContainer.js
var require_ReactRelayRefetchContainer = __commonJS({
  "../node_modules/react-relay/lib/ReactRelayRefetchContainer.js"(exports, module) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault()["default"];
    var _extends2 = _interopRequireDefault(require_extends());
    var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require_objectWithoutPropertiesLoose());
    var _objectSpread2 = _interopRequireDefault(require_objectSpread2());
    var _assertThisInitialized2 = _interopRequireDefault(require_assertThisInitialized());
    var _inheritsLoose2 = _interopRequireDefault(require_inheritsLoose());
    var _defineProperty2 = _interopRequireDefault(require_defineProperty());
    var _excluded = ["componentRef", "__relayContext", "__rootIsQueryRenderer"];
    var buildReactRelayContainer = require_buildReactRelayContainer();
    var getRootVariablesForFragments = require_getRootVariablesForFragments();
    var _require = require_ReactRelayContainerUtils();
    var getContainerName = _require.getContainerName;
    var ReactRelayContext = require_ReactRelayContext();
    var ReactRelayQueryFetcher = require_ReactRelayQueryFetcher();
    var _require2 = require_RelayContext();
    var assertRelayContext = _require2.assertRelayContext;
    var areEqual = require_areEqual();
    var React = require_react();
    var _require3 = require_relay_runtime();
    var Observable = _require3.Observable;
    var createFragmentSpecResolver = _require3.createFragmentSpecResolver;
    var createOperationDescriptor = _require3.createOperationDescriptor;
    var getDataIDsFromObject = _require3.getDataIDsFromObject;
    var getRequest = _require3.getRequest;
    var getVariablesFromObject = _require3.getVariablesFromObject;
    var isScalarAndEqual = _require3.isScalarAndEqual;
    var warning = require_warning();
    function createContainerWithFragments(Component, fragments, taggedNode) {
      var _class;
      var containerName = getContainerName(Component);
      return _class = (function(_React$Component) {
        (0, _inheritsLoose2["default"])(_class2, _React$Component);
        function _class2(props) {
          var _props$__rootIsQueryR, _this;
          _this = _React$Component.call(this, props) || this;
          (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_handleFragmentDataUpdate", function() {
            var resolverFromThisUpdate = _this.state.resolver;
            _this.setState(function(updatedState) {
              return resolverFromThisUpdate === updatedState.resolver ? {
                data: updatedState.resolver.resolve()
              } : null;
            });
          });
          (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_refetch", function(refetchVariables, renderVariables, observerOrCallback, options) {
            if (_this._isUnmounted) {
              true ? warning(false, "ReactRelayRefetchContainer: Unexpected call of `refetch` on unmounted container `%s`. It looks like some instances of your container still trying to refetch the data but they already unmounted. Please make sure you clear all timers, intervals, async calls, etc that may trigger `refetch`.", containerName) : void 0;
              return {
                dispose: function dispose() {
                }
              };
            }
            var _assertRelayContext = assertRelayContext(_this.props.__relayContext), environment = _assertRelayContext.environment;
            var rootVariables = getRootVariablesForFragments(fragments, _this.props);
            var fetchVariables = typeof refetchVariables === "function" ? refetchVariables(_this._getFragmentVariables()) : refetchVariables;
            fetchVariables = (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, rootVariables), fetchVariables);
            var fragmentVariables = renderVariables ? (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, fetchVariables), renderVariables) : fetchVariables;
            var cacheConfig = options ? {
              force: !!options.force
            } : void 0;
            if (cacheConfig != null && (options === null || options === void 0 ? void 0 : options.metadata) != null) {
              cacheConfig.metadata = options === null || options === void 0 ? void 0 : options.metadata;
            }
            var observer = typeof observerOrCallback === "function" ? {
              next: observerOrCallback,
              error: observerOrCallback
            } : observerOrCallback || {};
            var query = getRequest(taggedNode);
            var operation = createOperationDescriptor(query, fetchVariables, cacheConfig);
            _this.state.localVariables = fetchVariables;
            _this._refetchSubscription && _this._refetchSubscription.unsubscribe();
            var refetchSubscription;
            var storeSnapshot = _this._getQueryFetcher().lookupInStore(environment, operation, options === null || options === void 0 ? void 0 : options.fetchPolicy);
            if (storeSnapshot != null) {
              _this.state.resolver.setVariables(fragmentVariables, operation.request.node);
              _this.setState(function(latestState) {
                return {
                  data: latestState.resolver.resolve(),
                  contextForChildren: {
                    environment: _this.props.__relayContext.environment
                  }
                };
              }, function() {
                observer.next && observer.next();
                observer.complete && observer.complete();
              });
              return {
                dispose: function dispose() {
                }
              };
            }
            _this._getQueryFetcher().execute({
              environment,
              operation,
              preservePreviousReferences: true
            }).mergeMap(function(response) {
              _this.state.resolver.setVariables(fragmentVariables, operation.request.node);
              return Observable.create(function(sink) {
                return _this.setState(function(latestState) {
                  return {
                    data: latestState.resolver.resolve(),
                    contextForChildren: {
                      environment: _this.props.__relayContext.environment
                    }
                  };
                }, function() {
                  sink.next();
                  sink.complete();
                });
              });
            })["finally"](function() {
              if (_this._refetchSubscription === refetchSubscription) {
                _this._refetchSubscription = null;
              }
            }).subscribe((0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, observer), {}, {
              start: function start(subscription) {
                _this._refetchSubscription = refetchSubscription = subscription;
                observer.start && observer.start(subscription);
              }
            }));
            return {
              dispose: function dispose() {
                refetchSubscription && refetchSubscription.unsubscribe();
              }
            };
          });
          var relayContext = assertRelayContext(props.__relayContext);
          var rootIsQueryRenderer = (_props$__rootIsQueryR = props.__rootIsQueryRenderer) !== null && _props$__rootIsQueryR !== void 0 ? _props$__rootIsQueryR : false;
          _this._refetchSubscription = null;
          var resolver = createFragmentSpecResolver(relayContext, containerName, fragments, props, rootIsQueryRenderer);
          _this.state = {
            data: resolver.resolve(),
            localVariables: null,
            prevProps: props,
            prevPropsContext: relayContext,
            contextForChildren: relayContext,
            relayProp: getRelayProp(relayContext.environment, _this._refetch),
            resolver
          };
          _this._isUnmounted = false;
          return _this;
        }
        var _proto = _class2.prototype;
        _proto.componentDidMount = function componentDidMount() {
          this._isUnmounted = false;
          this._subscribeToNewResolverAndRerenderIfStoreHasChanged();
        };
        _proto.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {
          if (this.state.resolver !== prevState.resolver) {
            prevState.resolver.dispose();
            this._queryFetcher && this._queryFetcher.dispose();
            this._refetchSubscription && this._refetchSubscription.unsubscribe();
            this._subscribeToNewResolverAndRerenderIfStoreHasChanged();
          } else {
            this._rerenderIfStoreHasChanged();
          }
        };
        _class2.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, prevState) {
          var _nextProps$__rootIsQu;
          var prevProps = prevState.prevProps;
          var relayContext = assertRelayContext(nextProps.__relayContext);
          var rootIsQueryRenderer = (_nextProps$__rootIsQu = nextProps.__rootIsQueryRenderer) !== null && _nextProps$__rootIsQu !== void 0 ? _nextProps$__rootIsQu : false;
          var prevIDs = getDataIDsFromObject(fragments, prevProps);
          var nextIDs = getDataIDsFromObject(fragments, nextProps);
          var prevRootVariables = getRootVariablesForFragments(fragments, prevProps);
          var nextRootVariables = getRootVariablesForFragments(fragments, nextProps);
          var resolver = prevState.resolver;
          if (prevState.prevPropsContext.environment !== relayContext.environment || !areEqual(prevRootVariables, nextRootVariables) || !areEqual(prevIDs, nextIDs)) {
            resolver = createFragmentSpecResolver(relayContext, containerName, fragments, nextProps, rootIsQueryRenderer);
            return {
              data: resolver.resolve(),
              localVariables: null,
              prevProps: nextProps,
              prevPropsContext: relayContext,
              contextForChildren: relayContext,
              relayProp: getRelayProp(relayContext.environment, prevState.relayProp.refetch),
              resolver
            };
          } else if (!prevState.localVariables) {
            resolver.setProps(nextProps);
          }
          var data = resolver.resolve();
          if (data !== prevState.data) {
            return {
              data,
              prevProps: nextProps
            };
          }
          return null;
        };
        _proto.componentWillUnmount = function componentWillUnmount() {
          this._isUnmounted = true;
          this.state.resolver.dispose();
          this._queryFetcher && this._queryFetcher.dispose();
          this._refetchSubscription && this._refetchSubscription.unsubscribe();
        };
        _proto.shouldComponentUpdate = function shouldComponentUpdate(nextProps, nextState) {
          if (nextState.data !== this.state.data || nextState.relayProp !== this.state.relayProp) {
            return true;
          }
          var keys = Object.keys(nextProps);
          for (var ii = 0; ii < keys.length; ii++) {
            var key = keys[ii];
            if (key === "__relayContext") {
              if (this.state.prevPropsContext.environment !== nextState.prevPropsContext.environment) {
                return true;
              }
            } else {
              if (!fragments.hasOwnProperty(key) && !isScalarAndEqual(nextProps[key], this.props[key])) {
                return true;
              }
            }
          }
          return false;
        };
        _proto._rerenderIfStoreHasChanged = function _rerenderIfStoreHasChanged() {
          var _this$state = this.state, data = _this$state.data, resolver = _this$state.resolver;
          var maybeNewData = resolver.resolve();
          if (data !== maybeNewData) {
            this.setState({
              data: maybeNewData
            });
          }
        };
        _proto._subscribeToNewResolverAndRerenderIfStoreHasChanged = function _subscribeToNewResolverAndRerenderIfStoreHasChanged() {
          var _this$state2 = this.state, data = _this$state2.data, resolver = _this$state2.resolver;
          var maybeNewData = resolver.resolve();
          resolver.setCallback(this.props, this._handleFragmentDataUpdate);
          if (data !== maybeNewData) {
            this.setState({
              data: maybeNewData
            });
          }
        };
        _proto._getFragmentVariables = function _getFragmentVariables() {
          return getVariablesFromObject(fragments, this.props);
        };
        _proto._getQueryFetcher = function _getQueryFetcher() {
          if (!this._queryFetcher) {
            this._queryFetcher = new ReactRelayQueryFetcher();
          }
          return this._queryFetcher;
        };
        _proto.render = function render() {
          var _this$props = this.props, componentRef = _this$props.componentRef, __relayContext = _this$props.__relayContext, __rootIsQueryRenderer = _this$props.__rootIsQueryRenderer, props = (0, _objectWithoutPropertiesLoose2["default"])(_this$props, _excluded);
          var _this$state3 = this.state, relayProp = _this$state3.relayProp, contextForChildren = _this$state3.contextForChildren;
          return React.createElement(ReactRelayContext.Provider, {
            value: contextForChildren
          }, React.createElement(Component, (0, _extends2["default"])({}, props, this.state.data, {
            ref: componentRef,
            relay: relayProp
          })));
        };
        return _class2;
      })(React.Component), (0, _defineProperty2["default"])(_class, "displayName", containerName), _class;
    }
    function getRelayProp(environment, refetch) {
      return {
        environment,
        refetch
      };
    }
    function createContainer(Component, fragmentSpec, taggedNode) {
      return buildReactRelayContainer(Component, fragmentSpec, function(ComponentClass, fragments) {
        return createContainerWithFragments(ComponentClass, fragments, taggedNode);
      });
    }
    module.exports = {
      createContainer
    };
  }
});

// ../node_modules/react-relay/lib/relay-hooks/useClientQuery.js
var require_useClientQuery = __commonJS({
  "../node_modules/react-relay/lib/relay-hooks/useClientQuery.js"(exports, module) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault()["default"];
    var _objectSpread2 = _interopRequireDefault(require_objectSpread2());
    var useLazyLoadQuery = require_useLazyLoadQuery();
    function useClientQuery(gqlQuery, variables, options) {
      var query = gqlQuery;
      return useLazyLoadQuery(query, variables, (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, options), {}, {
        fetchPolicy: "store-only"
      }));
    }
    module.exports = useClientQuery;
  }
});

// ../node_modules/react-relay/lib/relay-hooks/usePrefetchableForwardPaginationFragment.js
var require_usePrefetchableForwardPaginationFragment = __commonJS({
  "../node_modules/react-relay/lib/relay-hooks/usePrefetchableForwardPaginationFragment.js"(exports, module) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault()["default"];
    var _objectSpread2 = _interopRequireDefault(require_objectSpread2());
    var useFragment = require_useFragment();
    var useLoadMoreFunction = require_useLoadMoreFunction();
    var useRefetchableFragmentInternal = require_useRefetchableFragmentInternal();
    var useRelayEnvironment = require_useRelayEnvironment();
    var useStaticFragmentNodeWarning = require_useStaticFragmentNodeWarning();
    var invariant = require_browser();
    var _require = require_react();
    var useCallback = _require.useCallback;
    var useDebugValue = _require.useDebugValue;
    var useEffect = _require.useEffect;
    var useLayoutEffect = _require.useLayoutEffect;
    var useMemo = _require.useMemo;
    var useRef = _require.useRef;
    var useState = _require.useState;
    var _require2 = require_relay_runtime();
    var getFragment = _require2.getFragment;
    var getFragmentIdentifier = _require2.getFragmentIdentifier;
    var getPaginationMetadata = _require2.getPaginationMetadata;
    var _require3 = require_relay_runtime();
    var ConnectionInterface = _require3.ConnectionInterface;
    var RelayFeatureFlags = _require3.RelayFeatureFlags;
    var getSelector = _require3.getSelector;
    var getValueAtPath = _require3.getValueAtPath;
    function usePrefetchableForwardPaginationFragment(fragmentInput, parentFragmentRef, bufferSize, initialSize, prefetchingLoadMoreOptions) {
      var _fragmentInput$metada, _fragmentInput$metada2;
      var minimalFetchSize = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 1;
      var disablePrefetching = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : false;
      var fragmentNode = getFragment(fragmentInput);
      useStaticFragmentNodeWarning(fragmentNode, "first argument of usePrefetchableForwardPaginationFragment()");
      var componentDisplayName = "usePrefetchableForwardPaginationFragment()";
      var _getPaginationMetadat = getPaginationMetadata(fragmentNode, componentDisplayName), connectionPathInFragmentData = _getPaginationMetadat.connectionPathInFragmentData, paginationRequest = _getPaginationMetadat.paginationRequest, paginationMetadata = _getPaginationMetadat.paginationMetadata;
      var _useRefetchableFragme = useRefetchableFragmentInternal(fragmentNode, parentFragmentRef, componentDisplayName), fragmentData = _useRefetchableFragme.fragmentData, fragmentRef = _useRefetchableFragme.fragmentRef, refetch = _useRefetchableFragme.refetch;
      var fragmentIdentifier = getFragmentIdentifier(fragmentNode, fragmentRef);
      var edgeKeys = useMemo(function() {
        var connection = getValueAtPath(fragmentData, connectionPathInFragmentData);
        if (connection == null) {
          return null;
        }
        var _ConnectionInterface$ = ConnectionInterface.get(), EDGES = _ConnectionInterface$.EDGES;
        return connection[EDGES];
      }, [connectionPathInFragmentData, fragmentData]);
      var sourceSize = edgeKeys == null ? -1 : edgeKeys.length;
      var _useState = useState(initialSize != null ? initialSize : sourceSize), _numInUse = _useState[0], setNumInUse = _useState[1];
      var numInUse = _numInUse;
      if (_numInUse === -1 && sourceSize !== -1) {
        numInUse = initialSize != null ? initialSize : sourceSize;
        setNumInUse(numInUse);
      }
      var environment = useRelayEnvironment();
      var _useState2 = useState(false), isLoadingMore = _useState2[0], reallySetIsLoadingMore = _useState2[1];
      var _useState3 = useState(false), isRefetching = _useState3[0], setIsRefetching = _useState3[1];
      var availableSizeRef = useRef(0);
      var setIsLoadingMore = useCallback(function(value) {
        var _environment$getSched;
        var schedule = (_environment$getSched = environment.getScheduler()) === null || _environment$getSched === void 0 ? void 0 : _environment$getSched.schedule;
        if (schedule) {
          schedule(function() {
            reallySetIsLoadingMore(value);
          });
        } else {
          reallySetIsLoadingMore(value);
        }
      }, [environment]);
      var isLoadingMoreRef = useRef(false);
      var observer = useMemo(function() {
        function setIsLoadingFalse() {
          isLoadingMoreRef.current = false;
          setIsLoadingMore(false);
        }
        return {
          start: function start() {
            isLoadingMoreRef.current = true;
            reallySetIsLoadingMore(true);
          },
          complete: setIsLoadingFalse,
          error: setIsLoadingFalse,
          unsubscribe: RelayFeatureFlags.ENABLE_USE_PAGINATION_IS_LOADING_FIX ? setIsLoadingFalse : void 0
        };
      }, [setIsLoadingMore]);
      var handleReset = useCallback(function() {
        if (!isRefetching) {
          var _environment$getSched2;
          var schedule = (_environment$getSched2 = environment.getScheduler()) === null || _environment$getSched2 === void 0 ? void 0 : _environment$getSched2.schedule;
          if (schedule) {
            schedule(function() {
              setNumInUse(-1);
            });
          } else {
            setNumInUse(-1);
          }
        }
        isLoadingMoreRef.current = false;
        setIsLoadingMore(false);
      }, [environment, isRefetching, setIsLoadingMore]);
      var _useLoadMoreFunction = useLoadMoreFunction({
        componentDisplayName,
        connectionPathInFragmentData,
        direction: "forward",
        fragmentData,
        fragmentIdentifier,
        fragmentNode,
        fragmentRef,
        paginationMetadata,
        paginationRequest,
        observer,
        onReset: handleReset
      }), loadMore = _useLoadMoreFunction[0], hasNext = _useLoadMoreFunction[1], disposeFetchNext = _useLoadMoreFunction[2];
      useLayoutEffect(function() {
        availableSizeRef.current = sourceSize - numInUse;
      }, [numInUse, sourceSize]);
      var prefetchingUNSTABLE_extraVariables = prefetchingLoadMoreOptions === null || prefetchingLoadMoreOptions === void 0 ? void 0 : prefetchingLoadMoreOptions.UNSTABLE_extraVariables;
      var prefetchingOnComplete = prefetchingLoadMoreOptions === null || prefetchingLoadMoreOptions === void 0 ? void 0 : prefetchingLoadMoreOptions.onComplete;
      var showMore = useCallback(function(numToAdd, options) {
        if (!isLoadingMoreRef.current || availableSizeRef.current >= 0) {
          availableSizeRef.current -= numToAdd;
          setNumInUse(function(lastNumInUse) {
            return lastNumInUse + numToAdd;
          });
          if (!isLoadingMoreRef.current && availableSizeRef.current < 0) {
            loadMore(Math.max(minimalFetchSize, Math.min(numToAdd, bufferSize - availableSizeRef.current)), options !== null && options !== void 0 ? options : {
              onComplete: prefetchingOnComplete,
              UNSTABLE_extraVariables: typeof prefetchingUNSTABLE_extraVariables === "function" ? prefetchingUNSTABLE_extraVariables({
                hasNext,
                data: fragmentData,
                getServerEdges: function getServerEdges() {
                  var selector = getSelector(edgesFragment, edgeKeys);
                  if (selector == null) {
                    return [];
                  }
                  !(selector.kind === "PluralReaderSelector") ? true ? invariant(false, "Expected a plural selector") : invariant(false) : void 0;
                  return selector.selectors.map(function(sel) {
                    return environment.lookup(sel).data;
                  });
                }
              }) : prefetchingUNSTABLE_extraVariables
            });
          }
        }
      }, [bufferSize, loadMore, minimalFetchSize, edgeKeys, fragmentData, prefetchingUNSTABLE_extraVariables, prefetchingOnComplete]);
      var edgesFragment = (_fragmentInput$metada = fragmentInput.metadata) === null || _fragmentInput$metada === void 0 ? void 0 : (_fragmentInput$metada2 = _fragmentInput$metada.refetch) === null || _fragmentInput$metada2 === void 0 ? void 0 : _fragmentInput$metada2.edgesFragment;
      !(edgesFragment != null) ? true ? invariant(false, "usePrefetchableForwardPaginationFragment: Expected the edge fragment to be defined, please make sure you have added `prefetchable_pagination: true`  to `@connection`") : invariant(false) : void 0;
      useEffect(function() {
        if (!isLoadingMoreRef.current && !isLoadingMore && !isRefetching && !disablePrefetching && hasNext && (sourceSize - numInUse < bufferSize || numInUse > sourceSize)) {
          var onComplete = prefetchingOnComplete;
          loadMore(Math.max(bufferSize - Math.max(sourceSize - numInUse, 0), numInUse - sourceSize, minimalFetchSize), {
            onComplete,
            UNSTABLE_extraVariables: typeof prefetchingUNSTABLE_extraVariables === "function" ? prefetchingUNSTABLE_extraVariables({
              hasNext,
              data: fragmentData,
              getServerEdges: function getServerEdges() {
                var selector = getSelector(edgesFragment, edgeKeys);
                if (selector == null) {
                  return [];
                }
                !(selector.kind === "PluralReaderSelector") ? true ? invariant(false, "Expected a plural selector") : invariant(false) : void 0;
                return selector.selectors.map(function(sel) {
                  return environment.lookup(sel).data;
                });
              }
            }) : prefetchingUNSTABLE_extraVariables
          });
        }
      }, [hasNext, bufferSize, isRefetching, loadMore, numInUse, prefetchingUNSTABLE_extraVariables, prefetchingOnComplete, sourceSize, edgeKeys, isLoadingMore, minimalFetchSize, environment, edgesFragment]);
      var realNumInUse = Math.min(numInUse, sourceSize);
      var derivedEdgeKeys = useMemo(function() {
        var _edgeKeys$slice;
        return (_edgeKeys$slice = edgeKeys === null || edgeKeys === void 0 ? void 0 : edgeKeys.slice(0, realNumInUse)) !== null && _edgeKeys$slice !== void 0 ? _edgeKeys$slice : [];
      }, [edgeKeys, realNumInUse]);
      var edges = useFragment(edgesFragment, derivedEdgeKeys);
      var refetchPagination = useCallback(function(variables, options) {
        disposeFetchNext();
        setIsRefetching(true);
        return refetch(variables, (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, options), {}, {
          onComplete: function onComplete(maybeError) {
            var _environment$getSched3, _options$onComplete;
            var schedule = (_environment$getSched3 = environment.getScheduler()) === null || _environment$getSched3 === void 0 ? void 0 : _environment$getSched3.schedule;
            if (schedule) {
              schedule(function() {
                setIsRefetching(false);
                setNumInUse(-1);
              });
            } else {
              setIsRefetching(false);
              setNumInUse(-1);
            }
            options === null || options === void 0 ? void 0 : (_options$onComplete = options.onComplete) === null || _options$onComplete === void 0 ? void 0 : _options$onComplete.call(options, maybeError);
          },
          __environment: void 0
        }));
      }, [disposeFetchNext, environment, refetch]);
      if (true) {
        useDebugValue({
          fragment: fragmentNode.name,
          data: fragmentData,
          hasNext,
          isLoadingNext: isLoadingMore
        });
      }
      return {
        edges,
        data: fragmentData,
        loadNext: showMore,
        hasNext: hasNext || sourceSize > numInUse,
        isLoadingNext: isLoadingMore && numInUse > sourceSize,
        refetch: refetchPagination
      };
    }
    module.exports = usePrefetchableForwardPaginationFragment;
  }
});

// ../node_modules/react-relay/lib/index.js
var require_lib = __commonJS({
  "../node_modules/react-relay/lib/index.js"(exports, module) {
    "use strict";
    var ReactRelayContext = require_ReactRelayContext();
    var ReactRelayFragmentContainer = require_ReactRelayFragmentContainer();
    var ReactRelayLocalQueryRenderer = require_ReactRelayLocalQueryRenderer();
    var ReactRelayPaginationContainer = require_ReactRelayPaginationContainer();
    var ReactRelayQueryRenderer = require_ReactRelayQueryRenderer();
    var ReactRelayRefetchContainer = require_ReactRelayRefetchContainer();
    var EntryPointContainer = require_EntryPointContainer_react();
    var loadEntryPoint = require_loadEntryPoint();
    var _require = require_loadQuery();
    var loadQuery = _require.loadQuery;
    var ProfilerContext = require_ProfilerContext();
    var RelayEnvironmentProvider = require_RelayEnvironmentProvider();
    var useClientQuery = require_useClientQuery();
    var useEntryPointLoader = require_useEntryPointLoader();
    var useFragment = require_useFragment();
    var useLazyLoadQuery = require_useLazyLoadQuery();
    var useMutation = require_useMutation();
    var usePaginationFragment = require_usePaginationFragment();
    var usePrefetchableForwardPaginationFragment = require_usePrefetchableForwardPaginationFragment();
    var usePreloadedQuery = require_usePreloadedQuery();
    var useQueryLoader = require_useQueryLoader();
    var useRefetchableFragment = require_useRefetchableFragment();
    var useRelayEnvironment = require_useRelayEnvironment();
    var useSubscribeToInvalidationState = require_useSubscribeToInvalidationState();
    var useSubscription = require_useSubscription();
    var RelayRuntime = require_relay_runtime();
    module.exports = {
      ConnectionHandler: RelayRuntime.ConnectionHandler,
      QueryRenderer: ReactRelayQueryRenderer,
      LocalQueryRenderer: ReactRelayLocalQueryRenderer,
      MutationTypes: RelayRuntime.MutationTypes,
      RangeOperations: RelayRuntime.RangeOperations,
      ReactRelayContext,
      applyOptimisticMutation: RelayRuntime.applyOptimisticMutation,
      commitLocalUpdate: RelayRuntime.commitLocalUpdate,
      commitMutation: RelayRuntime.commitMutation,
      createFragmentContainer: ReactRelayFragmentContainer.createContainer,
      createPaginationContainer: ReactRelayPaginationContainer.createContainer,
      createRefetchContainer: ReactRelayRefetchContainer.createContainer,
      fetchQuery_DEPRECATED: RelayRuntime.fetchQuery_DEPRECATED,
      graphql: RelayRuntime.graphql,
      readInlineData: RelayRuntime.readInlineData,
      requestSubscription: RelayRuntime.requestSubscription,
      EntryPointContainer,
      RelayEnvironmentProvider,
      ProfilerContext,
      fetchQuery: RelayRuntime.fetchQuery,
      loadQuery,
      loadEntryPoint,
      useClientQuery,
      useFragment,
      useLazyLoadQuery,
      useEntryPointLoader,
      useQueryLoader,
      useMutation,
      usePaginationFragment,
      usePreloadedQuery,
      useRefetchableFragment,
      usePrefetchableForwardPaginationFragment,
      useRelayEnvironment,
      useSubscribeToInvalidationState,
      useSubscription
    };
  }
});

// ../node_modules/react-relay/index.js
var require_react_relay = __commonJS({
  "../node_modules/react-relay/index.js"(exports, module) {
    module.exports = require_lib();
  }
});
export default require_react_relay();
//# sourceMappingURL=react-relay.js.map
