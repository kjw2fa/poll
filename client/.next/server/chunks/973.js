"use strict";exports.id=973,exports.ids=[973],exports.modules={90973:(a,b,c)=>{c.d(b,{q:()=>n});let d="object"==typeof performance&&performance&&"function"==typeof performance.now?performance:Date,e=new Set,f="object"==typeof process&&process?process:{},g=(a,b,c,d)=>{"function"==typeof f.emitWarning?f.emitWarning(a,b,c,d):console.error(`[${c}] ${b}: ${a}`)},h=globalThis.AbortController,i=globalThis.AbortSignal;if(void 0===h){i=class{onabort;_onabort=[];reason;aborted=!1;addEventListener(a,b){this._onabort.push(b)}},h=class{constructor(){b()}signal=new i;abort(a){if(!this.signal.aborted){for(let b of(this.signal.reason=a,this.signal.aborted=!0,this.signal._onabort))b(a);this.signal.onabort?.(a)}}};let a=f.env?.LRU_CACHE_IGNORE_AC_WARNING!=="1",b=()=>{a&&(a=!1,g("AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.","NO_ABORT_CONTROLLER","ENOTSUP",b))}}Symbol("type");let j=a=>a&&a===Math.floor(a)&&a>0&&isFinite(a),k=a=>j(a)?a<=256?Uint8Array:a<=65536?Uint16Array:a<=0x100000000?Uint32Array:a<=Number.MAX_SAFE_INTEGER?l:null:null;class l extends Array{constructor(a){super(a),this.fill(0)}}class m{heap;length;static #a=!1;static create(a){let b=k(a);if(!b)return[];m.#a=!0;let c=new m(a,b);return m.#a=!1,c}constructor(a,b){if(!m.#a)throw TypeError("instantiate Stack using Stack.create(n)");this.heap=new b(a),this.length=0}push(a){this.heap[this.length++]=a}pop(){return this.heap[--this.length]}}class n{#b;#c;#d;#e;#f;#g;#h;#i;get perf(){return this.#i}ttl;ttlResolution;ttlAutopurge;updateAgeOnGet;updateAgeOnHas;allowStale;noDisposeOnSet;noUpdateTTL;maxEntrySize;sizeCalculation;noDeleteOnFetchRejection;noDeleteOnStaleGet;allowStaleOnFetchAbort;allowStaleOnFetchRejection;ignoreFetchAbort;#j;#k;#l;#m;#n;#o;#p;#q;#r;#s;#t;#u;#v;#w;#x;#y;#z;#A;static unsafeExposeInternals(a){return{starts:a.#v,ttls:a.#w,sizes:a.#u,keyMap:a.#l,keyList:a.#m,valList:a.#n,next:a.#o,prev:a.#p,get head(){return a.#q},get tail(){return a.#r},free:a.#s,isBackgroundFetch:b=>a.#B(b),backgroundFetch:(b,c,d,e)=>a.#C(b,c,d,e),moveToTail:b=>a.#D(b),indexes:b=>a.#E(b),rindexes:b=>a.#F(b),isStale:b=>a.#G(b)}}get max(){return this.#b}get maxSize(){return this.#c}get calculatedSize(){return this.#k}get size(){return this.#j}get fetchMethod(){return this.#g}get memoMethod(){return this.#h}get dispose(){return this.#d}get onInsert(){return this.#e}get disposeAfter(){return this.#f}constructor(a){let{max:b=0,ttl:c,ttlResolution:f=1,ttlAutopurge:h,updateAgeOnGet:i,updateAgeOnHas:l,allowStale:o,dispose:p,onInsert:q,disposeAfter:r,noDisposeOnSet:s,noUpdateTTL:t,maxSize:u=0,maxEntrySize:v=0,sizeCalculation:w,fetchMethod:x,memoMethod:y,noDeleteOnFetchRejection:z,noDeleteOnStaleGet:A,allowStaleOnFetchRejection:B,allowStaleOnFetchAbort:C,ignoreFetchAbort:D,perf:E}=a;if(void 0!==E&&"function"!=typeof E?.now)throw TypeError("perf option must have a now() method if specified");if(this.#i=E??d,0!==b&&!j(b))throw TypeError("max option must be a nonnegative integer");let F=b?k(b):Array;if(!F)throw Error("invalid max value: "+b);if(this.#b=b,this.#c=u,this.maxEntrySize=v||this.#c,this.sizeCalculation=w,this.sizeCalculation){if(!this.#c&&!this.maxEntrySize)throw TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");if("function"!=typeof this.sizeCalculation)throw TypeError("sizeCalculation set to non-function")}if(void 0!==y&&"function"!=typeof y)throw TypeError("memoMethod must be a function if defined");if(this.#h=y,void 0!==x&&"function"!=typeof x)throw TypeError("fetchMethod must be a function if specified");if(this.#g=x,this.#y=!!x,this.#l=new Map,this.#m=Array(b).fill(void 0),this.#n=Array(b).fill(void 0),this.#o=new F(b),this.#p=new F(b),this.#q=0,this.#r=0,this.#s=m.create(b),this.#j=0,this.#k=0,"function"==typeof p&&(this.#d=p),"function"==typeof q&&(this.#e=q),"function"==typeof r?(this.#f=r,this.#t=[]):(this.#f=void 0,this.#t=void 0),this.#x=!!this.#d,this.#A=!!this.#e,this.#z=!!this.#f,this.noDisposeOnSet=!!s,this.noUpdateTTL=!!t,this.noDeleteOnFetchRejection=!!z,this.allowStaleOnFetchRejection=!!B,this.allowStaleOnFetchAbort=!!C,this.ignoreFetchAbort=!!D,0!==this.maxEntrySize){if(0!==this.#c&&!j(this.#c))throw TypeError("maxSize must be a positive integer if specified");if(!j(this.maxEntrySize))throw TypeError("maxEntrySize must be a positive integer if specified");this.#H()}if(this.allowStale=!!o,this.noDeleteOnStaleGet=!!A,this.updateAgeOnGet=!!i,this.updateAgeOnHas=!!l,this.ttlResolution=j(f)||0===f?f:1,this.ttlAutopurge=!!h,this.ttl=c||0,this.ttl){if(!j(this.ttl))throw TypeError("ttl must be a positive integer if specified");this.#I()}if(0===this.#b&&0===this.ttl&&0===this.#c)throw TypeError("At least one of max, maxSize, or ttl is required");if(!this.ttlAutopurge&&!this.#b&&!this.#c){let a="LRU_CACHE_UNBOUNDED";e.has(a)||(e.add(a),g("TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.","UnboundedCacheWarning",a,n))}}getRemainingTTL(a){return this.#l.has(a)?1/0:0}#I(){let a=new l(this.#b),b=new l(this.#b);this.#w=a,this.#v=b,this.#J=(c,d,e=this.#i.now())=>{if(b[c]=0!==d?e:0,a[c]=d,0!==d&&this.ttlAutopurge){let a=setTimeout(()=>{this.#G(c)&&this.#K(this.#m[c],"expire")},d+1);a.unref&&a.unref()}},this.#L=c=>{b[c]=0!==a[c]?this.#i.now():0},this.#M=(e,f)=>{if(a[f]){let g=a[f],h=b[f];if(!g||!h)return;e.ttl=g,e.start=h,e.now=c||d();let i=e.now-h;e.remainingTTL=g-i}};let c=0,d=()=>{let a=this.#i.now();if(this.ttlResolution>0){c=a;let b=setTimeout(()=>c=0,this.ttlResolution);b.unref&&b.unref()}return a};this.getRemainingTTL=e=>{let f=this.#l.get(e);if(void 0===f)return 0;let g=a[f],h=b[f];return g&&h?g-((c||d())-h):1/0},this.#G=e=>{let f=b[e],g=a[e];return!!g&&!!f&&(c||d())-f>g}}#L=()=>{};#M=()=>{};#J=()=>{};#G=()=>!1;#H(){let a=new l(this.#b);this.#k=0,this.#u=a,this.#N=b=>{this.#k-=a[b],a[b]=0},this.#O=(a,b,c,d)=>{if(this.#B(b))return 0;if(!j(c))if(d){if("function"!=typeof d)throw TypeError("sizeCalculation must be a function");if(!j(c=d(b,a)))throw TypeError("sizeCalculation return invalid (expect positive integer)")}else throw TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");return c},this.#P=(b,c,d)=>{if(a[b]=c,this.#c){let c=this.#c-a[b];for(;this.#k>c;)this.#Q(!0)}this.#k+=a[b],d&&(d.entrySize=c,d.totalCalculatedSize=this.#k)}}#N=a=>{};#P=(a,b,c)=>{};#O=(a,b,c,d)=>{if(c||d)throw TypeError("cannot set size without setting maxSize or maxEntrySize on cache");return 0};*#E({allowStale:a=this.allowStale}={}){if(this.#j)for(let b=this.#r;this.#R(b)&&((a||!this.#G(b))&&(yield b),b!==this.#q);)b=this.#p[b]}*#F({allowStale:a=this.allowStale}={}){if(this.#j)for(let b=this.#q;this.#R(b)&&((a||!this.#G(b))&&(yield b),b!==this.#r);)b=this.#o[b]}#R(a){return void 0!==a&&this.#l.get(this.#m[a])===a}*entries(){for(let a of this.#E())void 0===this.#n[a]||void 0===this.#m[a]||this.#B(this.#n[a])||(yield[this.#m[a],this.#n[a]])}*rentries(){for(let a of this.#F())void 0===this.#n[a]||void 0===this.#m[a]||this.#B(this.#n[a])||(yield[this.#m[a],this.#n[a]])}*keys(){for(let a of this.#E()){let b=this.#m[a];void 0===b||this.#B(this.#n[a])||(yield b)}}*rkeys(){for(let a of this.#F()){let b=this.#m[a];void 0===b||this.#B(this.#n[a])||(yield b)}}*values(){for(let a of this.#E())void 0===this.#n[a]||this.#B(this.#n[a])||(yield this.#n[a])}*rvalues(){for(let a of this.#F())void 0===this.#n[a]||this.#B(this.#n[a])||(yield this.#n[a])}[Symbol.iterator](){return this.entries()}[Symbol.toStringTag]="LRUCache";find(a,b={}){for(let c of this.#E()){let d=this.#n[c],e=this.#B(d)?d.__staleWhileFetching:d;if(void 0!==e&&a(e,this.#m[c],this))return this.get(this.#m[c],b)}}forEach(a,b=this){for(let c of this.#E()){let d=this.#n[c],e=this.#B(d)?d.__staleWhileFetching:d;void 0!==e&&a.call(b,e,this.#m[c],this)}}rforEach(a,b=this){for(let c of this.#F()){let d=this.#n[c],e=this.#B(d)?d.__staleWhileFetching:d;void 0!==e&&a.call(b,e,this.#m[c],this)}}purgeStale(){let a=!1;for(let b of this.#F({allowStale:!0}))this.#G(b)&&(this.#K(this.#m[b],"expire"),a=!0);return a}info(a){let b=this.#l.get(a);if(void 0===b)return;let c=this.#n[b],d=this.#B(c)?c.__staleWhileFetching:c;if(void 0===d)return;let e={value:d};if(this.#w&&this.#v){let a=this.#w[b],c=this.#v[b];a&&c&&(e.ttl=a-(this.#i.now()-c),e.start=Date.now())}return this.#u&&(e.size=this.#u[b]),e}dump(){let a=[];for(let b of this.#E({allowStale:!0})){let c=this.#m[b],d=this.#n[b],e=this.#B(d)?d.__staleWhileFetching:d;if(void 0===e||void 0===c)continue;let f={value:e};if(this.#w&&this.#v){f.ttl=this.#w[b];let a=this.#i.now()-this.#v[b];f.start=Math.floor(Date.now()-a)}this.#u&&(f.size=this.#u[b]),a.unshift([c,f])}return a}load(a){for(let[b,c]of(this.clear(),a)){if(c.start){let a=Date.now()-c.start;c.start=this.#i.now()-a}this.set(b,c.value,c)}}set(a,b,c={}){if(void 0===b)return this.delete(a),this;let{ttl:d=this.ttl,start:e,noDisposeOnSet:f=this.noDisposeOnSet,sizeCalculation:g=this.sizeCalculation,status:h}=c,{noUpdateTTL:i=this.noUpdateTTL}=c,j=this.#O(a,b,c.size||0,g);if(this.maxEntrySize&&j>this.maxEntrySize)return h&&(h.set="miss",h.maxEntrySizeExceeded=!0),this.#K(a,"set"),this;let k=0===this.#j?void 0:this.#l.get(a);if(void 0===k)k=0===this.#j?this.#r:0!==this.#s.length?this.#s.pop():this.#j===this.#b?this.#Q(!1):this.#j,this.#m[k]=a,this.#n[k]=b,this.#l.set(a,k),this.#o[this.#r]=k,this.#p[k]=this.#r,this.#r=k,this.#j++,this.#P(k,j,h),h&&(h.set="add"),i=!1,this.#A&&this.#e?.(b,a,"add");else{this.#D(k);let c=this.#n[k];if(b!==c){if(this.#y&&this.#B(c)){c.__abortController.abort(Error("replaced"));let{__staleWhileFetching:b}=c;void 0!==b&&!f&&(this.#x&&this.#d?.(b,a,"set"),this.#z&&this.#t?.push([b,a,"set"]))}else!f&&(this.#x&&this.#d?.(c,a,"set"),this.#z&&this.#t?.push([c,a,"set"]));if(this.#N(k),this.#P(k,j,h),this.#n[k]=b,h){h.set="replace";let a=c&&this.#B(c)?c.__staleWhileFetching:c;void 0!==a&&(h.oldValue=a)}}else h&&(h.set="update");this.#A&&this.onInsert?.(b,a,b===c?"update":"replace")}if(0===d||this.#w||this.#I(),this.#w&&(i||this.#J(k,d,e),h&&this.#M(h,k)),!f&&this.#z&&this.#t){let a,b=this.#t;for(;a=b?.shift();)this.#f?.(...a)}return this}pop(){try{for(;this.#j;){let a=this.#n[this.#q];if(this.#Q(!0),this.#B(a)){if(a.__staleWhileFetching)return a.__staleWhileFetching}else if(void 0!==a)return a}}finally{if(this.#z&&this.#t){let a,b=this.#t;for(;a=b?.shift();)this.#f?.(...a)}}}#Q(a){let b=this.#q,c=this.#m[b],d=this.#n[b];return this.#y&&this.#B(d)?d.__abortController.abort(Error("evicted")):(this.#x||this.#z)&&(this.#x&&this.#d?.(d,c,"evict"),this.#z&&this.#t?.push([d,c,"evict"])),this.#N(b),a&&(this.#m[b]=void 0,this.#n[b]=void 0,this.#s.push(b)),1===this.#j?(this.#q=this.#r=0,this.#s.length=0):this.#q=this.#o[b],this.#l.delete(c),this.#j--,b}has(a,b={}){let{updateAgeOnHas:c=this.updateAgeOnHas,status:d}=b,e=this.#l.get(a);if(void 0!==e){let a=this.#n[e];if(this.#B(a)&&void 0===a.__staleWhileFetching)return!1;if(!this.#G(e))return c&&this.#L(e),d&&(d.has="hit",this.#M(d,e)),!0;d&&(d.has="stale",this.#M(d,e))}else d&&(d.has="miss");return!1}peek(a,b={}){let{allowStale:c=this.allowStale}=b,d=this.#l.get(a);if(void 0===d||!c&&this.#G(d))return;let e=this.#n[d];return this.#B(e)?e.__staleWhileFetching:e}#C(a,b,c,d){let e=void 0===b?void 0:this.#n[b];if(this.#B(e))return e;let f=new h,{signal:g}=c;g?.addEventListener("abort",()=>f.abort(g.reason),{signal:f.signal});let i={signal:f.signal,options:c,context:d},j=(d,e=!1)=>{let{aborted:g}=f.signal,h=c.ignoreFetchAbort&&void 0!==d;if(c.status&&(g&&!e?(c.status.fetchAborted=!0,c.status.fetchError=f.signal.reason,h&&(c.status.fetchAbortIgnored=!0)):c.status.fetchResolved=!0),g&&!h&&!e)return k(f.signal.reason);let j=this.#n[b];return(j===m||h&&e&&void 0===j)&&(void 0===d?void 0!==m.__staleWhileFetching?this.#n[b]=m.__staleWhileFetching:this.#K(a,"fetch"):(c.status&&(c.status.fetchUpdated=!0),this.set(a,d,i.options))),d},k=d=>{let{aborted:e}=f.signal,g=e&&c.allowStaleOnFetchAbort,h=g||c.allowStaleOnFetchRejection,i=h||c.noDeleteOnFetchRejection;if(this.#n[b]===m&&(i&&void 0!==m.__staleWhileFetching?g||(this.#n[b]=m.__staleWhileFetching):this.#K(a,"fetch")),h)return c.status&&void 0!==m.__staleWhileFetching&&(c.status.returnedStale=!0),m.__staleWhileFetching;if(m.__returned===m)throw d},l=(b,d)=>{let g=this.#g?.(a,e,i);g&&g instanceof Promise&&g.then(a=>b(void 0===a?void 0:a),d),f.signal.addEventListener("abort",()=>{(!c.ignoreFetchAbort||c.allowStaleOnFetchAbort)&&(b(void 0),c.allowStaleOnFetchAbort&&(b=a=>j(a,!0)))})};c.status&&(c.status.fetchDispatched=!0);let m=new Promise(l).then(j,a=>(c.status&&(c.status.fetchRejected=!0,c.status.fetchError=a),k(a))),n=Object.assign(m,{__abortController:f,__staleWhileFetching:e,__returned:void 0});return void 0===b?(this.set(a,n,{...i.options,status:void 0}),b=this.#l.get(a)):this.#n[b]=n,n}#B(a){return!!this.#y&&!!a&&a instanceof Promise&&a.hasOwnProperty("__staleWhileFetching")&&a.__abortController instanceof h}async fetch(a,b={}){let{allowStale:c=this.allowStale,updateAgeOnGet:d=this.updateAgeOnGet,noDeleteOnStaleGet:e=this.noDeleteOnStaleGet,ttl:f=this.ttl,noDisposeOnSet:g=this.noDisposeOnSet,size:h=0,sizeCalculation:i=this.sizeCalculation,noUpdateTTL:j=this.noUpdateTTL,noDeleteOnFetchRejection:k=this.noDeleteOnFetchRejection,allowStaleOnFetchRejection:l=this.allowStaleOnFetchRejection,ignoreFetchAbort:m=this.ignoreFetchAbort,allowStaleOnFetchAbort:n=this.allowStaleOnFetchAbort,context:o,forceRefresh:p=!1,status:q,signal:r}=b;if(!this.#y)return q&&(q.fetch="get"),this.get(a,{allowStale:c,updateAgeOnGet:d,noDeleteOnStaleGet:e,status:q});let s={allowStale:c,updateAgeOnGet:d,noDeleteOnStaleGet:e,ttl:f,noDisposeOnSet:g,size:h,sizeCalculation:i,noUpdateTTL:j,noDeleteOnFetchRejection:k,allowStaleOnFetchRejection:l,allowStaleOnFetchAbort:n,ignoreFetchAbort:m,status:q,signal:r},t=this.#l.get(a);if(void 0===t){q&&(q.fetch="miss");let b=this.#C(a,t,s,o);return b.__returned=b}{let b=this.#n[t];if(this.#B(b)){let a=c&&void 0!==b.__staleWhileFetching;return q&&(q.fetch="inflight",a&&(q.returnedStale=!0)),a?b.__staleWhileFetching:b.__returned=b}let e=this.#G(t);if(!p&&!e)return q&&(q.fetch="hit"),this.#D(t),d&&this.#L(t),q&&this.#M(q,t),b;let f=this.#C(a,t,s,o),g=void 0!==f.__staleWhileFetching&&c;return q&&(q.fetch=e?"stale":"refresh",g&&e&&(q.returnedStale=!0)),g?f.__staleWhileFetching:f.__returned=f}}async forceFetch(a,b={}){let c=await this.fetch(a,b);if(void 0===c)throw Error("fetch() returned undefined");return c}memo(a,b={}){let c=this.#h;if(!c)throw Error("no memoMethod provided to constructor");let{context:d,forceRefresh:e,...f}=b,g=this.get(a,f);if(!e&&void 0!==g)return g;let h=c(a,g,{options:f,context:d});return this.set(a,h,f),h}get(a,b={}){let{allowStale:c=this.allowStale,updateAgeOnGet:d=this.updateAgeOnGet,noDeleteOnStaleGet:e=this.noDeleteOnStaleGet,status:f}=b,g=this.#l.get(a);if(void 0!==g){let b=this.#n[g],h=this.#B(b);return(f&&this.#M(f,g),this.#G(g))?(f&&(f.get="stale"),h)?(f&&c&&void 0!==b.__staleWhileFetching&&(f.returnedStale=!0),c?b.__staleWhileFetching:void 0):(e||this.#K(a,"expire"),f&&c&&(f.returnedStale=!0),c?b:void 0):(f&&(f.get="hit"),h)?b.__staleWhileFetching:(this.#D(g),d&&this.#L(g),b)}f&&(f.get="miss")}#S(a,b){this.#p[b]=a,this.#o[a]=b}#D(a){a!==this.#r&&(a===this.#q?this.#q=this.#o[a]:this.#S(this.#p[a],this.#o[a]),this.#S(this.#r,a),this.#r=a)}delete(a){return this.#K(a,"delete")}#K(a,b){let c=!1;if(0!==this.#j){let d=this.#l.get(a);if(void 0!==d)if(c=!0,1===this.#j)this.#T(b);else{this.#N(d);let c=this.#n[d];if(this.#B(c)?c.__abortController.abort(Error("deleted")):(this.#x||this.#z)&&(this.#x&&this.#d?.(c,a,b),this.#z&&this.#t?.push([c,a,b])),this.#l.delete(a),this.#m[d]=void 0,this.#n[d]=void 0,d===this.#r)this.#r=this.#p[d];else if(d===this.#q)this.#q=this.#o[d];else{let a=this.#p[d];this.#o[a]=this.#o[d];let b=this.#o[d];this.#p[b]=this.#p[d]}this.#j--,this.#s.push(d)}}if(this.#z&&this.#t?.length){let a,b=this.#t;for(;a=b?.shift();)this.#f?.(...a)}return c}clear(){return this.#T("delete")}#T(a){for(let b of this.#F({allowStale:!0})){let c=this.#n[b];if(this.#B(c))c.__abortController.abort(Error("deleted"));else{let d=this.#m[b];this.#x&&this.#d?.(c,d,a),this.#z&&this.#t?.push([c,d,a])}}if(this.#l.clear(),this.#n.fill(void 0),this.#m.fill(void 0),this.#w&&this.#v&&(this.#w.fill(0),this.#v.fill(0)),this.#u&&this.#u.fill(0),this.#q=0,this.#r=0,this.#s.length=0,this.#k=0,this.#j=0,this.#z&&this.#t){let a,b=this.#t;for(;a=b?.shift();)this.#f?.(...a)}}}}};